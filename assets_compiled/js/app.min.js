/**
 * @ngdoc module
 * @name tabs
 */

var module = angular.module('tabs', []);

var totalCtrl = 0;
module.controller('ModuleTestController', function ($scope) {
    var vm = this;
    vm.scope = $scope;
    vm.totalCtrl = totalCtrl++;

    vm.someMethod = function (text) {
        console.log('someMethod', text)
    }
})

module
    .controller('TabsetController', ['$scope', function TabsetCtrl($scope) {
        var ctrl = this,
            tabs = ctrl.tabs = $scope.tabs = [];

        ctrl.select = function (selectedTab) {
            angular.forEach(tabs, function (tab) {
                if (tab.active && tab !== selectedTab) {
                    tab.active = false;
                    tab.onDeselect();
                }
            });
            selectedTab.active = true;
            selectedTab.onSelect();
        };

        ctrl.addTab = function addTab(tab) {
            tabs.push(tab);
            // we can't run the select function on the first tab
            // since that would select it twice
            if (tabs.length === 1 && tab.active !== false) {
                tab.active = true;
            } else if (tab.active) {
                ctrl.select(tab);
            }
            else {
                tab.active = false;
            }
        };

        ctrl.removeTab = function removeTab(tab) {
            var index = tabs.indexOf(tab);
            //Select a new tab if the tab to be removed is selected and not destroyed
            if (tab.active && tabs.length > 1 && !destroyed) {
                //If this is the last tab, select the previous tab. else, the next tab.
                var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
                ctrl.select(tabs[newActiveIndex]);
            }
            tabs.splice(index, 1);
        };

        var destroyed;
        $scope.$on('$destroy', function () {
            destroyed = true;
        });
    }])

    .directive('tabset', function () {
        return {
            restrict: 'EA',
            transclude: true,
            replace: true,
            scope: {
                type: '@'
            },
            controller: 'TabsetController',
            template: '<div>\
                            <ul class="nav nav-{{type || \'tabs\'}}" ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}" ng-transclude></ul>\
                            <div class="tab-content">\
                                <div class="tab-pane"\
                                ng-repeat="tab in tabs"\
                                ng-class="{active: tab.active}"\
                                tab-content-transclude="tab">\
                                </div>\
                            </div>\
                        </div>',
            link: function (scope, element, attrs) {
                scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
                scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
            }
        };
    })

    .directive('tab', ['$parse', '$log', function ($parse, $log) {
        return {
            require: '^tabset',
            restrict: 'EA',
            replace: true,
            template: '<li ng-class="{active: active, disabled: disabled}">\
                            <a href ng-click="select()" tab-heading-transclude>{{heading}}</a>\
                       </li>',
            transclude: true,
            scope: {
                active: '=?',
                heading: '@',
                onSelect: '&select', //This callback is called in contentHeadingTransclude
                //once it inserts the tab's content into the dom
                onDeselect: '&deselect'
            },
            controller: function () {
                //Empty controller so other directives can require being 'under' a tab
            },
            link: function (scope, elm, attrs, tabsetCtrl, transclude) {
                scope.$watch('active', function (active) {
                    if (active) {
                        tabsetCtrl.select(scope);
                    }
                });

                scope.disabled = false;
                if (attrs.disable) {
                    scope.$parent.$watch($parse(attrs.disable), function (value) {
                        scope.disabled = !!value;
                    });
                }

                // Deprecation support of "disabled" parameter
                // fix(tab): IE9 disabled attr renders grey text on enabled tab #2677
                // This code is duplicated from the lines above to make it easy to remove once
                // the feature has been completely deprecated
                if (attrs.disabled) {
                    $log.warn('Use of "disabled" attribute has been deprecated, please use "disable"');
                    scope.$parent.$watch($parse(attrs.disabled), function (value) {
                        scope.disabled = !!value;
                    });
                }

                scope.select = function () {
                    if (!scope.disabled) {
                        scope.active = true;
                    }
                };

                tabsetCtrl.addTab(scope);
                scope.$on('$destroy', function () {
                    tabsetCtrl.removeTab(scope);
                });

                //We need to transclude later, once the content container is ready.
                //when this link happens, we're inside a tab heading.
                scope.$transcludeFn = transclude;
            }
        };
    }])

    .directive('tabHeadingTransclude', [function () {
        return {
            restrict: 'A',
            require: '^tab',
            link: function (scope, elm, attrs, tabCtrl) {
                scope.$watch('headingElement', function updateHeadingElement(heading) {
                    if (heading) {
                        elm.html('');
                        elm.append(heading);
                    }
                });
            }
        };
    }])
    .directive('tabContentTransclude', function () {
        return {
            restrict: 'A',
            require: '^tabset',
            link: function (scope, elm, attrs) {
                var tab = scope.$eval(attrs.tabContentTransclude);

                //Now our tab is ready to be transcluded: both the tab heading area
                //and the tab content area are loaded.  Transclude 'em both.
                tab.$transcludeFn(tab.$parent, function (contents) {
                    angular.forEach(contents, function (node) {
                        if (isTabHeading(node)) {
                            //Let tabHeadingTransclude know.
                            tab.headingElement = node;
                        } else {
                            elm.append(node);
                        }
                    });
                });
            }
        };
        function isTabHeading(node) {
            return node.tagName && (
                node.hasAttribute('tab-heading') ||
                    node.hasAttribute('data-tab-heading') ||
                    node.tagName.toLowerCase() === 'tab-heading' ||
                    node.tagName.toLowerCase() === 'data-tab-heading'
                );
        }
    })


/* ------------------------------------------------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------------------------------------------------ */
/* ------------------------------------------------------------------------------------------------------------------ */

module
    .directive('cTabs', TabsDirective)
    .directive('cTab', TabDirective);

function TabsDirective() {
    return {
        restrict: 'E',
        transclude: true,
        replace: true,
        scope: {},
        link: postLink,
        controller: TabsController,
        controllerAs: 'tabsCtrl',
        template: function (element, attr) {
            attr["tabsTemplate"] = element.html();

            return '<div class="tabsContainer">\
                        <div class="headLine">\
                            <div class="tabTitle" ng-repeat="tab in tabsCtrl.tabs" ng-click="tabsCtrl.selectTab(tab)">{{tab.label}}</div>\
                        </div>\
                        <div class="tabContent" ng-transclude></div>\
                    </div>';
        }
    };

    function postLink() {

    }
}

function TabsController($scope, $attrs, $compile) {
    var tabsCtrl = this;

    tabsCtrl.scope = $scope;
    tabsCtrl.tabs = [];


    tabsCtrl.addTab = function (tab) {
        tabsCtrl.tabs.push(tab)
    };

    tabsCtrl.selectTab = function (tab) {
        tab.activeCallback && tab.scope.$eval(tab.activeCallback);
    }
}

TabsController.$inject = ["$scope", "$attrs", "$compile"];


function TabDirective($templateRequest, $compile) {
    return {
        restrict: 'E',
        require: '^?cTabs',
        replace: true,
        transclude: true,
        template: '<div class="tabContent" ng-transclude></div>',
//        scope: {
//            activeFn: "&"
//        },
        link: postLink
    };


    function postLink(scope, element, attr, ctrl) {

        if (attr.tplUrl) {
            element.html(
                $compile(
                    angular.element('<div ng-include="\'' + attr.tplUrl + '\'">')
                )(scope)
            )
        }

        if (typeof ctrl == 'undefined' || ctrl == null) {
            return;
        }

        ctrl.addTab({
            label: attr.label,
            content: element.html(),
            scope: scope,
            activeCallback: attr.activeFn
        })
    }
}

TabDirective.$inject = ["$templateRequest", "$compile"];
_app = {};

_app.urlCombine = function () {
    function normalize(str) {
        return str
            .replace(/[\/]+/g, '/')
            .replace(/\/\?/g, '?')
            .replace(/\/\#/g, '#')
            .replace(/\:\//g, '://');
    }

    var joined = [].slice.call(arguments, 0).filter(function (val) {
        return val !== '';
    }).join('/');

    return normalize(joined);
};

_app.cloneObj = function (obj, exclude) {
    if (obj === null || typeof(obj) !== 'object' || 'isActiveClone' in obj)
        return obj;

    var temp = obj.constructor(); // changed

    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && (typeof exclude == 'undefined' || exclude.indexOf(key) == -1)) {
            obj['isActiveClone'] = null;
            temp[key] = clone(obj[key]);
            delete obj['isActiveClone'];
        }
    }

    return temp;
};

_app.getQueryParams = function (str) {
    return (document.location.hash || str || document.location.search)
        .replace(/(^.+\?)/, '')
        .split("&")
        .map(
            function (n) {
                return n = n.split("="), this[n[0]] = n[1], this
            }.bind({})
        )[0];
};

var lastObjectIndex = 0;
Function.prototype.new = function () {
    var args = arguments
    var constructor = this

    function Custom() {
        constructor.apply(this, args)
        this.$idx = lastObjectIndex++;
    }

    Custom.prototype = constructor.prototype
    return new Custom
}

_app.addIndex = function(obj){
    obj.$idx = obj.$idx || lastObjectIndex++;
    return obj.$idx;
}

var HashCode = function () {

    var serialize = function (object) {
        // Private
        var type, serializedCode = "";
        type = typeof object;

        if (type === 'object') {
            var element;
            for (element in object) {
                serializedCode += "[" + type + ":" + element + serialize(object[element]) + "]";
            }

        } else if (type === 'function') {
            serializedCode += "[" + type + ":" + object.toString() + "]";
        } else {
            serializedCode += "[" + type + ":" + object + "]";
        }

        return serializedCode.replace(/\s/g, "");
    };

    // Public, API
    return {
        value: function (object) {
            return MD5(serialize(object));
        }
    };
}();

var MD5 = function (string) {

    function RotateLeft(lValue, iShiftBits) {
        return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
    }

    function AddUnsigned(lX, lY) {
        var lX4, lY4, lX8, lY8, lResult;
        lX8 = (lX & 0x80000000);
        lY8 = (lY & 0x80000000);
        lX4 = (lX & 0x40000000);
        lY4 = (lY & 0x40000000);
        lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
        if (lX4 & lY4) {
            return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
        }
        if (lX4 | lY4) {
            if (lResult & 0x40000000) {
                return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
            } else {
                return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
            }
        } else {
            return (lResult ^ lX8 ^ lY8);
        }
    }

    function F(x, y, z) {
        return (x & y) | ((~x) & z);
    }

    function G(x, y, z) {
        return (x & z) | (y & (~z));
    }

    function H(x, y, z) {
        return (x ^ y ^ z);
    }

    function I(x, y, z) {
        return (y ^ (x | (~z)));
    }

    function FF(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    };

    function GG(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    };

    function HH(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    };

    function II(a, b, c, d, x, s, ac) {
        a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
        return AddUnsigned(RotateLeft(a, s), b);
    };

    function ConvertToWordArray(string) {
        var lWordCount;
        var lMessageLength = string.length;
        var lNumberOfWords_temp1 = lMessageLength + 8;
        var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
        var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
        var lWordArray = Array(lNumberOfWords - 1);
        var lBytePosition = 0;
        var lByteCount = 0;
        while (lByteCount < lMessageLength) {
            lWordCount = (lByteCount - (lByteCount % 4)) / 4;
            lBytePosition = (lByteCount % 4) * 8;
            lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) << lBytePosition));
            lByteCount++;
        }
        lWordCount = (lByteCount - (lByteCount % 4)) / 4;
        lBytePosition = (lByteCount % 4) * 8;
        lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
        lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
        lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
        return lWordArray;
    };

    function WordToHex(lValue) {
        var WordToHexValue = "", WordToHexValue_temp = "", lByte, lCount;
        for (lCount = 0; lCount <= 3; lCount++) {
            lByte = (lValue >>> (lCount * 8)) & 255;
            WordToHexValue_temp = "0" + lByte.toString(16);
            WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
        }
        return WordToHexValue;
    };

    function Utf8Encode(string) {
        string = string.replace(/\r\n/g, "\n");
        var utftext = "";

        for (var n = 0; n < string.length; n++) {

            var c = string.charCodeAt(n);

            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if ((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }

        }

        return utftext;
    };

    var x = Array();
    var k, AA, BB, CC, DD, a, b, c, d;
    var S11 = 7, S12 = 12, S13 = 17, S14 = 22;
    var S21 = 5, S22 = 9 , S23 = 14, S24 = 20;
    var S31 = 4, S32 = 11, S33 = 16, S34 = 23;
    var S41 = 6, S42 = 10, S43 = 15, S44 = 21;

    string = Utf8Encode(string);

    x = ConvertToWordArray(string);

    a = 0x67452301;
    b = 0xEFCDAB89;
    c = 0x98BADCFE;
    d = 0x10325476;

    for (k = 0; k < x.length; k += 16) {
        AA = a;
        BB = b;
        CC = c;
        DD = d;
        a = FF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
        d = FF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
        c = FF(c, d, a, b, x[k + 2], S13, 0x242070DB);
        b = FF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
        a = FF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
        d = FF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
        c = FF(c, d, a, b, x[k + 6], S13, 0xA8304613);
        b = FF(b, c, d, a, x[k + 7], S14, 0xFD469501);
        a = FF(a, b, c, d, x[k + 8], S11, 0x698098D8);
        d = FF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
        c = FF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
        b = FF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
        a = FF(a, b, c, d, x[k + 12], S11, 0x6B901122);
        d = FF(d, a, b, c, x[k + 13], S12, 0xFD987193);
        c = FF(c, d, a, b, x[k + 14], S13, 0xA679438E);
        b = FF(b, c, d, a, x[k + 15], S14, 0x49B40821);
        a = GG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
        d = GG(d, a, b, c, x[k + 6], S22, 0xC040B340);
        c = GG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
        b = GG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
        a = GG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
        d = GG(d, a, b, c, x[k + 10], S22, 0x2441453);
        c = GG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
        b = GG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
        a = GG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
        d = GG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
        c = GG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
        b = GG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
        a = GG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
        d = GG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
        c = GG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
        b = GG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
        a = HH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
        d = HH(d, a, b, c, x[k + 8], S32, 0x8771F681);
        c = HH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
        b = HH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
        a = HH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
        d = HH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
        c = HH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
        b = HH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
        a = HH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
        d = HH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
        c = HH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
        b = HH(b, c, d, a, x[k + 6], S34, 0x4881D05);
        a = HH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
        d = HH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
        c = HH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
        b = HH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
        a = II(a, b, c, d, x[k + 0], S41, 0xF4292244);
        d = II(d, a, b, c, x[k + 7], S42, 0x432AFF97);
        c = II(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
        b = II(b, c, d, a, x[k + 5], S44, 0xFC93A039);
        a = II(a, b, c, d, x[k + 12], S41, 0x655B59C3);
        d = II(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
        c = II(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
        b = II(b, c, d, a, x[k + 1], S44, 0x85845DD1);
        a = II(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
        d = II(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
        c = II(c, d, a, b, x[k + 6], S43, 0xA3014314);
        b = II(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
        a = II(a, b, c, d, x[k + 4], S41, 0xF7537E82);
        d = II(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
        c = II(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
        b = II(b, c, d, a, x[k + 9], S44, 0xEB86D391);
        a = AddUnsigned(a, AA);
        b = AddUnsigned(b, BB);
        c = AddUnsigned(c, CC);
        d = AddUnsigned(d, DD);
    }

    var temp = WordToHex(a) + WordToHex(b) + WordToHex(c) + WordToHex(d);

    return temp.toLowerCase();
}
var app = angular.module('ArchiviserApplication', ['ngMaterial', 'ngMdIcons', 'ngResource', 'ngRoute', 'ui.router', 'vAccordion', 'ngFileUpload']);

app.config(function ($mdThemingProvider) {
    var customBlueMap = $mdThemingProvider.extendPalette('light-blue', {
        'contrastDefaultColor': 'light',
        'contrastDarkColors': ['50'],
        '50': 'ffffff'
    });
    $mdThemingProvider.definePalette('customBlue', customBlueMap);
    $mdThemingProvider.theme('default')
        .primaryPalette('customBlue', {
            'default': '500',
            'hue-1': '50'
        })
        .accentPalette('pink');
    $mdThemingProvider.theme('input', 'default')
        .primaryPalette('grey')
});

app.config(['$httpProvider', '$provide', function ($httpProvider, $provide) {

    $httpProvider.defaults.transformRequest.push(function (data, headersGetter) {
        var d, utf8_data;
        utf8_data = data;
        if (!angular.isUndefined(data)) {
            d = angular.fromJson(data);
            d["_utf8"] = "✓";
            utf8_data = angular.toJson(d);
        }
        return utf8_data;
    });

    $provide.factory('httpInterceptor', ['$q', '$rootScope', function ($q, $rootScope) {
        return {
            'request': function (config) {
                // intercept and change config: e.g. change the URL
                // config.url += '?nocache=' + (new Date()).getTime();
                // broadcasting 'httpRequest' event
                $rootScope.$broadcast('httpRequest', config);
                return config || $q.when(config);
            },
            'response': function (response) {
                // we can intercept and change response here...
                // broadcasting 'httpResponse' event
                $rootScope.$broadcast('httpResponse', response);
                return response || $q.when(response);
            },
            'requestError': function (rejection) {
                // broadcasting 'httpRequestError' event
                $rootScope.$broadcast('httpRequestError', rejection);
                return $q.reject(rejection);
            },
            'responseError': function (rejection) {
                // broadcasting 'httpResponseError' event
                $rootScope.$broadcast('httpResponseError', rejection);
                return $q.reject(rejection);
            }
        };
    }]);

    $httpProvider.interceptors.push('httpInterceptor');

    $provide.decorator('$q', function ($delegate) {
        var defer = $delegate.defer;
        $delegate.defer = function () {
            var deferred = defer();
            deferred.promise.success = function (fn) {
                deferred.promise.then(function() {
                    fn.apply(this, arguments);
                });
                return deferred.promise;
            };
            deferred.promise.error = function (fn) {
                deferred.promise.then(null, function() {
                    fn.apply(this, arguments);
                });
                return deferred.promise;
            };
            return deferred;
        };
        return $delegate;
    });

}]);

app.run(['$rootScope', '$state', '$stateParams', function ($rootScope, $state, $stateParams) {
    $rootScope.$state = $state;
    $rootScope.$stateParams = $stateParams;
    $rootScope.stateCountInProgress = 0;

    $rootScope.$on('$stateChangeStart',
        function (event, toState, toParams, fromState, fromParams) {
            $rootScope.stateCountInProgress++;
        }
    );

    $rootScope.$on('$viewContentLoaded',
        function (event, toState, toParams, fromState, fromParams) {
            setTimeout(function () {
                if ($rootScope.stateCountInProgress > 0) {
                    $rootScope.stateCountInProgress--;
                }
            }, 500)
        }
    );

    $rootScope.$on('httpRequest', function () {

    });

    $rootScope.$on('httpResponse', function () {

    });

    $rootScope.$on('$stateChangeSuccess', function (event, to, toParams, from, fromParams) {
        $rootScope.currentState = to;
    });

    $rootScope.safeApply = function(fn) {
        var phase = this.$root.$$phase;
        if(phase == '$apply' || phase == '$digest') {
            if(fn && (typeof(fn) === 'function')) {
                fn();
            }
        } else {
            this.$apply(fn);
        }
    };

    $rootScope.ENV = {
        isIndex : /.+index(\.html)?$/.test(window.location.pathname.toLowerCase())
    };
}]);
app.config(['$routeProvider', function ($routeProvider) {

    var otherwiseUrl = '/';

    $routeProvider

        .otherwise(otherwiseUrl);
}]);
app.config(['$stateProvider', '$urlRouterProvider', function ($stateProvider, $urlRouterProvider) {

    $stateProvider
        .state('main', {
            url: "/main",
            templateUrl: _app.urlCombine(window.rootUrl, 'html/main_view.html'),
            controller: 'MainViewController as mvc'
        })
        .state('service', {
            url: "/service",
            templateUrl: _app.urlCombine(window.rootUrl, 'html/service_view.html'),
            controller: 'ServiceViewController as svc'
        })
        .state('portfolio', {
            url: "/portfolio",
            templateUrl: _app.urlCombine(window.rootUrl, 'html/portfolio_view.html'),
            controller: 'PortfolioViewController as pvc'
        })
        .state('contact_us', {
            url: "/contact_us",
            templateUrl: _app.urlCombine(window.rootUrl, 'html/contact_us_view.html'),
            controller: 'ContactUsViewController as cuvc'
        })
        .state('projects', {
            url: "/projects",
            templateUrl: _app.urlCombine(window.rootUrl, 'html/projects_view.html'),
            controller: 'ProjectsViewController as pvc'
        })
        .state('project', {
            url: "/project?id",
            templateUrl: _app.urlCombine(window.rootUrl, 'html/project_view.html'),
            controller: 'ProjectViewController as projvc'
        })
        .state('tasks', {
            url: "/tasks",
            templateUrl: _app.urlCombine(window.rootUrl, 'html/tasks_view.html'),
            controller: 'TasksViewController as tvc'
        })
        .state('task', {
            url: "/task?id",
            templateUrl: _app.urlCombine(window.rootUrl, 'html/task_view.html'),
            controller: 'TaskViewController as taskvc'
        })
        .state('models', {
            url: "/models",
            templateUrl: _app.urlCombine(window.rootUrl, 'html/models_view.html'),
            controller: 'ModelsViewController as mvc'
        })
        .state('scenes', {
            url: "/scenes",
            templateUrl: _app.urlCombine(window.rootUrl, 'html/scenes_view.html'),
            controller: 'ScenesViewController as svc'
        })
        .state('help', {
            url: "/help",
            templateUrl: _app.urlCombine(window.rootUrl, 'html/help_view.html'),
            controller: 'HelpViewController as hvc'
        })
        .state('profile', {
            url: "/profile?id",
            templateUrl: _app.urlCombine(window.rootUrl, 'html/profile_view.html'),
            controller: 'ProfileViewController as pvc'
        })
    ;
}]);

(function(){

    var customFilters = angular.module('customFilters', []);

    customFilters.filter('usd', ['$filter', function($filter) {
        return function(input) {
            if(input == 0) return '$0.00';
            if(input == '' || input == null || typeof(input) == 'undefined') return '';
            // BUG:
//            console.log($filter('currency')(input, '$', 2));
            var preFormated = $filter('currency')(input, '$', 2);
            if(preFormated && !/^$/.test(preFormated)) {
                preFormated = preFormated.replace(/^./, '');// to replace "В"
            }
            return preFormated;
        };
    }]);

    customFilters.filter('money', ['$filter', function($filter) {
        return function(input, sym) {
            if(input == 0) return (sym ? sym+'0.00' : '0.00');
            if(input == '' || input == null || typeof(input) == 'undefined') return '';
            var preFormated = $filter('currency')(input, '', 2);
            if(preFormated && !/^\d/.test(preFormated)) {
                preFormated = preFormated.replace(/^\D+/, '');// to replace "В"
            }
            return (sym ? sym+preFormated : preFormated);
        };
    }]);

    customFilters.filter('dt', ['$filter', function() {
        return function(input) {
            if(isNaN(input)) return input;
            return new Date(Number(input)).format("mm/dd/yyyy");
        };
    }]);

})();
(function (app) {

    app.service('DB', DB);

    DB.$inject = ["$http"];

    function DB($http) {
        var self = this;
        self.state = {};

        self.url = '/api/';

        self.query = function (ctrl, method, params, callback) {

            var request = $http({
                method: method,
                url: self.url + ctrl,
                params: params
            });

            var successCallback = function (successRes) {
                console.log([ctrl + ' , ' + method + ' success res', params, successRes]);
                callback(successRes);
            };

            var failedCallback = function (failedRes) {
                console.log([ctrl + ' , ' + method + ' failed res', params, failedRes]);
                callback(failedRes);
            };

            return (request.then(successCallback, failedCallback));
        };
        //-----------------------------------------------------
        //-----------------------------------------------------

        //-----------------------------------------------------
        //Profile functions
        //-----------------------------------------------------
        self.login = function (params, callback) {
            self.query('login', 'POST', params, callback);
        };

        self.logout = function (params, callback) {
            self.query('logout', 'POST', params, callback);
        };

        self.register = function (params, callback) {
            self.query('register', 'POST', params, callback);
        };

        self.getProfile = function (params, callback) {
            self.query('profile', 'GET', params, callback);
        };

        self.getProfileDetails = function (id, callback) {
            self.query('profile_details/' + id, 'GET', {}, callback);
        };

        self.saveProfileDetails = function (params, callback) {
            self.query('profile_details/' + params._id, 'PUT', params, callback);
        };
        //-----------------------------------------------------
        //-----------------------------------------------------

        //-----------------------------------------------------
        //Projects functions
        //-----------------------------------------------------
        self.getProjects = function (callback) {
            var params = {};
            self.query('projects', 'GET', params, callback);
        };

        self.getProject = function (projectId, callback) {
            var params = {};
            self.query('projects/' + projectId, 'GET', params, callback);
        };

        self.addProject = function (params, callback) {
            self.query('projects', 'POST', params, callback);
        };

        self.deleteProject = function (callback) {
            var params = { projectId : 1 };
            self.query('projects', 'DELETE', params, callback);
        };

        self.addMessageToProjectChat = function (params, callback) {
            console.log('add message to project chat not implemented');
            //self.query('project', 'POST', params, callback);
        };
        //-----------------------------------------------------
        //-----------------------------------------------------

        //-----------------------------------------------------
        //Tasks functions
        //-----------------------------------------------------
        self.getTasks = function (params, callback) {
            self.query('tasks', 'GET', params, callback);
        };

        self.getTask = function (taskId, callback) {
            self.query('tasks/' + taskId, 'GET', {}, callback);
        };

        self.createTask = function (params, callback) {
            self.query('tasks', 'POST', params, callback);
        };

        self.deleteTask = function (params, callback) {
            var params = { taskId : 1 };
            self.query('tasks', 'DELETE', params, callback);
        };

        self.addMessageToTaskChat = function (params, callback) {
            console.log('add message to project chat not implemented');
            //self.query('task', 'POST', params, callback);
        };
        //-----------------------------------------------------
        //-----------------------------------------------------

        //-----------------------------------------------------
        //Scenes functions
        //-----------------------------------------------------
        self.getScenes = function (params, callback) {
            self.query('scenes', 'GET', params, callback);
        };

        self.deleteScene = function (callback) {
            //var params = {};
            //self.query('scenes', 'POST', params, callback);
        };

        self.changeScene = function (params, callback) {
            //self.query('scenes', 'POST', params, callback);
        };
        //-----------------------------------------------------
        //-----------------------------------------------------

        //-----------------------------------------------------
        //Models functions
        //-----------------------------------------------------
        self.getModels = function (params, callback) {
            self.query('models', 'GET', params, callback);
        };

        self.deleteModel = function (callback) {
            //var params = {};
            //self.query('models', 'POST', params, callback);
        };

        self.changeModel = function (params, callback) {
            //self.query('models', 'POST', params, callback);
        };
        //-----------------------------------------------------
        //-----------------------------------------------------

        //-----------------------------------------------------
        //Portfolio functions
        //-----------------------------------------------------
        self.getPortfolio = function (params, callback) {
            self.query('portfolio', 'GET', params, callback);
        };
        //-----------------------------------------------------
        //-----------------------------------------------------
    }
})(app);
/*
 * ngDialog - easy modals and popup windows
 * http://github.com/likeastore/ngDialog
 * (c) 2013-2015 MIT License, https://likeastore.com
 */

(function (root, factory) {
    if (typeof module !== 'undefined' && module.exports) {
        // CommonJS
        if (typeof angular === 'undefined') {
            module.exports = factory(require('angular'));
        } else {
            module.exports = factory(angular);
        }
    } else if (typeof define === 'function' && define.amd) {
        // AMD
        define(['angular'], factory);
    } else {
        // Global Variables
        factory(root.angular);
    }
}(this, function (angular) {
    'use strict';

    var m = angular.module('ngDialog', []);

    var $el = angular.element;
    var isDef = angular.isDefined;
    var style = (document.body || document.documentElement).style;
    var animationEndSupport = isDef(style.animation) || isDef(style.WebkitAnimation) || isDef(style.MozAnimation) || isDef(style.MsAnimation) || isDef(style.OAnimation);
    var animationEndEvent = 'animationend webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend';
    var focusableElementSelector = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]';
    var disabledAnimationClass = 'ngdialog-disabled-animation';
    var forceElementsReload = { html: false, body: false };
    var scopes = {};
    var openIdStack = [];
    var keydownIsBound = false;

    m.provider('ngDialog', function () {
        var defaults = this.defaults = {
            className: 'ngdialog-theme-default',
            disableAnimation: false,
            plain: false,
            showClose: true,
            closeByDocument: true,
            closeByEscape: true,
            closeByNavigation: false,
            appendTo: false,
            preCloseCallback: false,
            overlay: true,
            cache: true,
            trapFocus: true,
            preserveFocus: true,
            ariaAuto: true,
            ariaRole: null,
            ariaLabelledById: null,
            ariaLabelledBySelector: null,
            ariaDescribedById: null,
            ariaDescribedBySelector: null
        };

        this.setForceHtmlReload = function (_useIt) {
            forceElementsReload.html = _useIt || false;
        };

        this.setForceBodyReload = function (_useIt) {
            forceElementsReload.body = _useIt || false;
        };

        this.setDefaults = function (newDefaults) {
            angular.extend(defaults, newDefaults);
        };

        var globalID = 0, dialogsCount = 0, closeByDocumentHandler, defers = {};

        this.$get = ['$document', '$templateCache', '$compile', '$q', '$http', '$rootScope', '$timeout', '$window', '$controller', '$injector',
            function ($document, $templateCache, $compile, $q, $http, $rootScope, $timeout, $window, $controller, $injector) {
                var $elements = [];

                angular.forEach(
                    ['html', 'body'],
                    function(elementName) {
                        $elements[elementName] = $document.find(elementName);
                        if (forceElementsReload[elementName]) {
                            var eventName = privateMethods.getRouterLocationEventName();
                            $rootScope.$on(eventName, function () {
                                $elements[elementName] = $document.find(elementName);
                            });
                        }
                    }
                );

                var privateMethods = {
                    onDocumentKeydown: function (event) {
                        if (event.keyCode === 27) {
                            publicMethods.close('$escape');
                        }
                    },

                    activate: function($dialog) {
                        var options = $dialog.data('$ngDialogOptions');

                        if (options.trapFocus) {
                            $dialog.on('keydown', privateMethods.onTrapFocusKeydown);

                            // Catch rogue changes (eg. after unfocusing everything by clicking a non-focusable element)
                            $elements.body.on('keydown', privateMethods.onTrapFocusKeydown);
                        }
                    },

                    deactivate: function ($dialog) {
                        $dialog.off('keydown', privateMethods.onTrapFocusKeydown);
                        $elements.body.off('keydown', privateMethods.onTrapFocusKeydown);
                    },

                    deactivateAll: function () {
                        angular.forEach(function(el) {
                            var $dialog = angular.element(el);
                            privateMethods.deactivate($dialog);
                        });
                    },

                    setBodyPadding: function (width) {
                        var originalBodyPadding = parseInt(($elements.body.css('padding-right') || 0), 10);
                        $elements.body.css('padding-right', (originalBodyPadding + width) + 'px');
                        $elements.body.data('ng-dialog-original-padding', originalBodyPadding);
                    },

                    resetBodyPadding: function () {
                        var originalBodyPadding = $elements.body.data('ng-dialog-original-padding');
                        if (originalBodyPadding) {
                            $elements.body.css('padding-right', originalBodyPadding + 'px');
                        } else {
                            $elements.body.css('padding-right', '');
                        }
                    },

                    performCloseDialog: function ($dialog, value) {
                        var options = $dialog.data('$ngDialogOptions');
                        var id = $dialog.attr('id');
                        var scope = scopes[id];

                        if (!scope) {
                            // Already closed
                            return;
                        }

                        if (typeof $window.Hammer !== 'undefined') {
                            var hammerTime = scope.hammerTime;
                            hammerTime.off('tap', closeByDocumentHandler);
                            hammerTime.destroy && hammerTime.destroy();
                            delete scope.hammerTime;
                        } else {
                            $dialog.unbind('click');
                        }

                        if (dialogsCount === 1) {
                            $elements.body.unbind('keydown');
                        }

                        if (!$dialog.hasClass('ngdialog-closing')){
                            dialogsCount -= 1;
                        }

                        var previousFocus = $dialog.data('$ngDialogPreviousFocus');
                        if (previousFocus) {
                            previousFocus.focus();
                        }

                        $rootScope.$broadcast('ngDialog.closing', $dialog, value);
                        dialogsCount = dialogsCount < 0 ? 0 : dialogsCount;
                        if (animationEndSupport && !options.disableAnimation) {
                            scope.$destroy();
                            $dialog.unbind(animationEndEvent).bind(animationEndEvent, function () {
                                privateMethods.closeDialogElement($dialog, value);
                            }).addClass('ngdialog-closing');
                        } else {
                            scope.$destroy();
                            privateMethods.closeDialogElement($dialog, value);
                        }
                        if (defers[id]) {
                            defers[id].resolve({
                                id: id,
                                value: value,
                                $dialog: $dialog,
                                remainingDialogs: dialogsCount
                            });
                            delete defers[id];
                        }
                        if (scopes[id]) {
                            delete scopes[id];
                        }
                        openIdStack.splice(openIdStack.indexOf(id), 1);
                        if (!openIdStack.length) {
                            $elements.body.unbind('keydown', privateMethods.onDocumentKeydown);
                            keydownIsBound = false;
                        }
                    },

                    closeDialogElement: function($dialog, value) {
                        $dialog.remove();
                        if (dialogsCount === 0) {
                            $elements.html.removeClass('ngdialog-open');
                            $elements.body.removeClass('ngdialog-open');
                            privateMethods.resetBodyPadding();
                        }
                        $rootScope.$broadcast('ngDialog.closed', $dialog, value);
                    },

                    closeDialog: function ($dialog, value) {
                        var preCloseCallback = $dialog.data('$ngDialogPreCloseCallback');

                        if (preCloseCallback && angular.isFunction(preCloseCallback)) {

                            var preCloseCallbackResult = preCloseCallback.call($dialog, value);

                            if (angular.isObject(preCloseCallbackResult)) {
                                if (preCloseCallbackResult.closePromise) {
                                    preCloseCallbackResult.closePromise.then(function () {
                                        privateMethods.performCloseDialog($dialog, value);
                                    });
                                } else {
                                    preCloseCallbackResult.then(function () {
                                        privateMethods.performCloseDialog($dialog, value);
                                    }, function () {
                                        return;
                                    });
                                }
                            } else if (preCloseCallbackResult !== false) {
                                privateMethods.performCloseDialog($dialog, value);
                            }
                        } else {
                            privateMethods.performCloseDialog($dialog, value);
                        }
                    },

                    onTrapFocusKeydown: function(ev) {
                        var el = angular.element(ev.currentTarget);
                        var $dialog;

                        if (el.hasClass('ngdialog')) {
                            $dialog = el;
                        } else {
                            $dialog = privateMethods.getActiveDialog();

                            if ($dialog === null) {
                                return;
                            }
                        }

                        var isTab = (ev.keyCode === 9);
                        var backward = (ev.shiftKey === true);

                        if (isTab) {
                            privateMethods.handleTab($dialog, ev, backward);
                        }
                    },

                    handleTab: function($dialog, ev, backward) {
                        var focusableElements = privateMethods.getFocusableElements($dialog);

                        if (focusableElements.length === 0) {
                            if (document.activeElement) {
                                document.activeElement.blur();
                            }
                            return;
                        }

                        var currentFocus = document.activeElement;
                        var focusIndex = Array.prototype.indexOf.call(focusableElements, currentFocus);

                        var isFocusIndexUnknown = (focusIndex === -1);
                        var isFirstElementFocused = (focusIndex === 0);
                        var isLastElementFocused = (focusIndex === focusableElements.length - 1);

                        var cancelEvent = false;

                        if (backward) {
                            if (isFocusIndexUnknown || isFirstElementFocused) {
                                focusableElements[focusableElements.length - 1].focus();
                                cancelEvent = true;
                            }
                        } else {
                            if (isFocusIndexUnknown || isLastElementFocused) {
                                focusableElements[0].focus();
                                cancelEvent = true;
                            }
                        }

                        if (cancelEvent) {
                            ev.preventDefault();
                            ev.stopPropagation();
                        }
                    },

                    autoFocus: function($dialog) {
                        var dialogEl = $dialog[0];

                        // Browser's (Chrome 40, Forefix 37, IE 11) don't appear to honor autofocus on the dialog, but we should
                        var autoFocusEl = dialogEl.querySelector('*[autofocus]');
                        if (autoFocusEl !== null) {
                            autoFocusEl.focus();

                            if (document.activeElement === autoFocusEl) {
                                return;
                            }

                            // Autofocus element might was display: none, so let's continue
                        }

                        var focusableElements = privateMethods.getFocusableElements($dialog);

                        if (focusableElements.length > 0) {
                            focusableElements[0].focus();
                            return;
                        }

                        // We need to focus something for the screen readers to notice the dialog
                        var contentElements = privateMethods.filterVisibleElements(dialogEl.querySelectorAll('h1,h2,h3,h4,h5,h6,p,span'));

                        if (contentElements.length > 0) {
                            var contentElement = contentElements[0];
                            $el(contentElement).attr('tabindex', '-1').css('outline', '0');
                            contentElement.focus();
                        }
                    },

                    getFocusableElements: function ($dialog) {
                        var dialogEl = $dialog[0];

                        var rawElements = dialogEl.querySelectorAll(focusableElementSelector);

                        return privateMethods.filterVisibleElements(rawElements);
                    },

                    filterVisibleElements: function (els) {
                        var visibleFocusableElements = [];

                        for (var i = 0; i < els.length; i++) {
                            var el = els[i];

                            if (el.offsetWidth > 0 || el.offsetHeight > 0) {
                                visibleFocusableElements.push(el);
                            }
                        }

                        return visibleFocusableElements;
                    },

                    getActiveDialog: function () {
                        var dialogs = document.querySelectorAll('.ngdialog');

                        if (dialogs.length === 0) {
                            return null;
                        }

                        // TODO: This might be incorrect if there are a mix of open dialogs with different 'appendTo' values
                        return $el(dialogs[dialogs.length - 1]);
                    },

                    applyAriaAttributes: function ($dialog, options) {
                        if (options.ariaAuto) {
                            if (!options.ariaRole) {
                                var detectedRole = (privateMethods.getFocusableElements($dialog).length > 0) ?
                                    'dialog' :
                                    'alertdialog';

                                options.ariaRole = detectedRole;
                            }

                            if (!options.ariaLabelledBySelector) {
                                options.ariaLabelledBySelector = 'h1,h2,h3,h4,h5,h6';
                            }

                            if (!options.ariaDescribedBySelector) {
                                options.ariaDescribedBySelector = 'article,section,p';
                            }
                        }

                        if (options.ariaRole) {
                            $dialog.attr('role', options.ariaRole);
                        }

                        privateMethods.applyAriaAttribute(
                            $dialog, 'aria-labelledby', options.ariaLabelledById, options.ariaLabelledBySelector);

                        privateMethods.applyAriaAttribute(
                            $dialog, 'aria-describedby', options.ariaDescribedById, options.ariaDescribedBySelector);
                    },

                    applyAriaAttribute: function($dialog, attr, id, selector) {
                        if (id) {
                            $dialog.attr(attr, id);
                        }

                        if (selector) {
                            var dialogId = $dialog.attr('id');

                            var firstMatch = $dialog[0].querySelector(selector);

                            if (!firstMatch) {
                                return;
                            }

                            var generatedId = dialogId + '-' + attr;

                            $el(firstMatch).attr('id', generatedId);

                            $dialog.attr(attr, generatedId);

                            return generatedId;
                        }
                    },

                    detectUIRouter: function() {
                        //Detect if ui-router module is installed if not return false
                        try {
                            angular.module("ui.router");
                            return true;
                        } catch(err) {
                            return false;
                        }
                    },

                    getRouterLocationEventName: function() {
                        if(privateMethods.detectUIRouter()) {
                            return '$stateChangeSuccess';
                        }
                        return '$locationChangeSuccess';
                    }
                };

                var publicMethods = {

                    /*
                     * @param {Object} options:
                     * - template {String} - id of ng-template, url for partial, plain string (if enabled)
                     * - plain {Boolean} - enable plain string templates, default false
                     * - scope {Object}
                     * - controller {String}
                     * - controllerAs {String}
                     * - className {String} - dialog theme class
                     * - disableAnimation {Boolean} - set to true to disable animation
                     * - showClose {Boolean} - show close button, default true
                     * - closeByEscape {Boolean} - default true
                     * - closeByDocument {Boolean} - default true
                     * - preCloseCallback {String|Function} - user supplied function name/function called before closing dialog (if set)
                     *
                     * @return {Object} dialog
                     */
                    open: function (opts) {
                        var options = angular.copy(defaults);
                        var localID = ++globalID;
                        var dialogID = 'ngdialog' + localID;
                        openIdStack.push(dialogID);

                        opts = opts || {};
                        angular.extend(options, opts);

                        var defer;
                        defers[dialogID] = defer = $q.defer();

                        var scope;
                        scopes[dialogID] = scope = angular.isObject(options.scope) ? options.scope.$new() : $rootScope.$new();

                        var $dialog, $dialogParent;

                        var resolve = angular.extend({}, options.resolve);

                        angular.forEach(resolve, function (value, key) {
                            resolve[key] = angular.isString(value) ? $injector.get(value) : $injector.invoke(value, null, null, key);
                        });

                        $q.all({
                            template: loadTemplate(options.template || options.templateUrl),
                            locals: $q.all(resolve)
                        }).then(function (setup) {
                                var template = setup.template,
                                    locals = setup.locals;

                                if (options.showClose) {
                                    template += '<div class="ngdialog-close"></div>';
                                }

                                $dialog = $el('<div id="ngdialog' + localID + '" class="ngdialog"></div>');
                                $dialog.html((options.overlay ?
                                    '<div class="ngdialog-overlay"></div><div class="ngdialog-content" role="document">' + template + '</div>' :
                                    '<div class="ngdialog-content" role="document">' + template + '</div>'));

                                $dialog.data('$ngDialogOptions', options);

                                scope.ngDialogId = dialogID;

                                if (options.data && angular.isString(options.data)) {
                                    var firstLetter = options.data.replace(/^\s*/, '')[0];
                                    scope.ngDialogData = (firstLetter === '{' || firstLetter === '[') ? angular.fromJson(options.data) : options.data;
                                    scope.ngDialogData.ngDialogId = dialogID;
                                } else if (options.data && angular.isObject(options.data)) {
                                    scope.ngDialogData = options.data;
                                    scope.ngDialogData.ngDialogId = dialogID;
                                }

                                if (options.controller && (angular.isString(options.controller) || angular.isArray(options.controller) || angular.isFunction(options.controller))) {

                                    var label;

                                    if (options.controllerAs && angular.isString(options.controllerAs)) {
                                        label = options.controllerAs;
                                    }

                                    var controllerInstance = $controller(options.controller, angular.extend(
                                        locals,
                                        {
                                            $scope: scope,
                                            $element: $dialog
                                        }),
                                        null,
                                        label
                                    );
                                    $dialog.data('$ngDialogControllerController', controllerInstance);
                                }

                                if (options.className) {
                                    $dialog.addClass(options.className);
                                }

                                if (options.disableAnimation) {
                                    $dialog.addClass(disabledAnimationClass);
                                }

                                if (options.appendTo && angular.isString(options.appendTo)) {
                                    $dialogParent = angular.element(document.querySelector(options.appendTo));
                                } else {
                                    $dialogParent = $elements.body;
                                }

                                privateMethods.applyAriaAttributes($dialog, options);

                                if (options.preCloseCallback) {
                                    var preCloseCallback;

                                    if (angular.isFunction(options.preCloseCallback)) {
                                        preCloseCallback = options.preCloseCallback;
                                    } else if (angular.isString(options.preCloseCallback)) {
                                        if (scope) {
                                            if (angular.isFunction(scope[options.preCloseCallback])) {
                                                preCloseCallback = scope[options.preCloseCallback];
                                            } else if (scope.$parent && angular.isFunction(scope.$parent[options.preCloseCallback])) {
                                                preCloseCallback = scope.$parent[options.preCloseCallback];
                                            } else if ($rootScope && angular.isFunction($rootScope[options.preCloseCallback])) {
                                                preCloseCallback = $rootScope[options.preCloseCallback];
                                            }
                                        }
                                    }

                                    if (preCloseCallback) {
                                        $dialog.data('$ngDialogPreCloseCallback', preCloseCallback);
                                    }
                                }

                                scope.closeThisDialog = function (value) {
                                    privateMethods.closeDialog($dialog, value);
                                };

                                $timeout(function () {
                                    var $activeDialogs = document.querySelectorAll('.ngdialog');
                                    privateMethods.deactivateAll($activeDialogs);

                                    $compile($dialog)(scope);
                                    var widthDiffs = $window.innerWidth - $elements.body.prop('clientWidth');
                                    $elements.html.addClass('ngdialog-open');
                                    $elements.body.addClass('ngdialog-open');
                                    var scrollBarWidth = widthDiffs - ($window.innerWidth - $elements.body.prop('clientWidth'));
                                    if (scrollBarWidth > 0) {
                                        privateMethods.setBodyPadding(scrollBarWidth);
                                    }
                                    $dialogParent.append($dialog);

                                    privateMethods.activate($dialog);

                                    if (options.trapFocus) {
                                        privateMethods.autoFocus($dialog);
                                    }

                                    if (options.name) {
                                        $rootScope.$broadcast('ngDialog.opened', {dialog: $dialog, name: options.name});
                                    } else {
                                        $rootScope.$broadcast('ngDialog.opened', $dialog);
                                    }
                                });

                                if (!keydownIsBound) {
                                    $elements.body.bind('keydown', privateMethods.onDocumentKeydown);
                                    keydownIsBound = true;
                                }

                                if (options.closeByNavigation) {
                                    var eventName = privateMethods.getRouterLocationEventName();
                                    $rootScope.$on(eventName, function () {
                                        privateMethods.closeDialog($dialog);
                                    });
                                }

                                if (options.preserveFocus) {
                                    $dialog.data('$ngDialogPreviousFocus', document.activeElement);
                                }

                                closeByDocumentHandler = function (event) {
                                    var isOverlay = options.closeByDocument ? $el(event.target).hasClass('ngdialog-overlay') : false;
                                    var isCloseBtn = $el(event.target).hasClass('ngdialog-close');

                                    if (isOverlay || isCloseBtn) {
                                        publicMethods.close($dialog.attr('id'), isCloseBtn ? '$closeButton' : '$document');
                                    }
                                };

                                if (typeof $window.Hammer !== 'undefined') {
                                    var hammerTime = scope.hammerTime = $window.Hammer($dialog[0]);
                                    hammerTime.on('tap', closeByDocumentHandler);
                                } else {
                                    $dialog.bind('click', closeByDocumentHandler);
                                }

                                dialogsCount += 1;

                                return publicMethods;
                            });

                        return {
                            id: dialogID,
                            closePromise: defer.promise,
                            close: function (value) {
                                privateMethods.closeDialog($dialog, value);
                            }
                        };

                        function loadTemplateUrl (tmpl, config) {
                            $rootScope.$broadcast('ngDialog.templateLoading', tmpl);
                            return $http.get(tmpl, (config || {})).then(function(res) {
                                $rootScope.$broadcast('ngDialog.templateLoaded', tmpl);
                                return res.data || '';
                            });
                        }

                        function loadTemplate (tmpl) {
                            if (!tmpl) {
                                return 'Empty template';
                            }

                            if (angular.isString(tmpl) && options.plain) {
                                return tmpl;
                            }

                            if (typeof options.cache === 'boolean' && !options.cache) {
                                return loadTemplateUrl(tmpl, {cache: false});
                            }

                            return loadTemplateUrl(tmpl, {cache: $templateCache});
                        }
                    },

                    /*
                     * @param {Object} options:
                     * - template {String} - id of ng-template, url for partial, plain string (if enabled)
                     * - plain {Boolean} - enable plain string templates, default false
                     * - name {String}
                     * - scope {Object}
                     * - controller {String}
                     * - controllerAs {String}
                     * - className {String} - dialog theme class
                     * - showClose {Boolean} - show close button, default true
                     * - closeByEscape {Boolean} - default false
                     * - closeByDocument {Boolean} - default false
                     * - preCloseCallback {String|Function} - user supplied function name/function called before closing dialog (if set); not called on confirm
                     *
                     * @return {Object} dialog
                     */
                    openConfirm: function (opts) {
                        var defer = $q.defer();

                        var options = {
                            closeByEscape: false,
                            closeByDocument: false
                        };
                        angular.extend(options, opts);

                        options.scope = angular.isObject(options.scope) ? options.scope.$new() : $rootScope.$new();
                        options.scope.confirm = function (value) {
                            defer.resolve(value);
                            var $dialog = $el(document.getElementById(openResult.id));
                            privateMethods.performCloseDialog($dialog, value);
                        };

                        var openResult = publicMethods.open(options);
                        openResult.closePromise.then(function (data) {
                            if (data) {
                                return defer.reject(data.value);
                            }
                            return defer.reject();
                        });

                        return defer.promise;
                    },

                    isOpen: function(id) {
                        var $dialog = $el(document.getElementById(id));
                        return $dialog.length > 0;
                    },

                    /*
                     * @param {String} id
                     * @return {Object} dialog
                     */
                    close: function (id, value) {
                        var $dialog = $el(document.getElementById(id));

                        if ($dialog.length) {
                            privateMethods.closeDialog($dialog, value);
                        } else {
                            if (id === '$escape') {
                                var topDialogId = openIdStack[openIdStack.length - 1];
                                $dialog = $el(document.getElementById(topDialogId));
                                if ($dialog.data('$ngDialogOptions').closeByEscape) {
                                    privateMethods.closeDialog($dialog, value);
                                }
                            } else {
                                publicMethods.closeAll(value);
                            }
                        }

                        return publicMethods;
                    },

                    closeAll: function (value) {
                        var $all = document.querySelectorAll('.ngdialog');

                        // Reverse order to ensure focus restoration works as expected
                        for (var i = $all.length - 1; i >= 0; i--) {
                            var dialog = $all[i];
                            privateMethods.closeDialog($el(dialog), value);
                        }
                    },

                    getOpenDialogs: function() {
                        return openIdStack;
                    },

                    getDefaults: function () {
                        return defaults;
                    }
                };

                return publicMethods;
            }];
    });

    m.directive('ngDialog', ['ngDialog', function (ngDialog) {
        return {
            restrict: 'A',
            scope: {
                ngDialogScope: '='
            },
            link: function (scope, elem, attrs) {
                elem.on('click', function (e) {
                    e.preventDefault();

                    var ngDialogScope = angular.isDefined(scope.ngDialogScope) ? scope.ngDialogScope : 'noScope';
                    angular.isDefined(attrs.ngDialogClosePrevious) && ngDialog.close(attrs.ngDialogClosePrevious);

                    var defaults = ngDialog.getDefaults();

                    ngDialog.open({
                        template: attrs.ngDialog,
                        className: attrs.ngDialogClass || defaults.className,
                        controller: attrs.ngDialogController,
                        controllerAs: attrs.ngDialogControllerAs,
                        bindToController: attrs.ngDialogBindToController,
                        scope: ngDialogScope,
                        data: attrs.ngDialogData,
                        showClose: attrs.ngDialogShowClose === 'false' ? false : (attrs.ngDialogShowClose === 'true' ? true : defaults.showClose),
                        closeByDocument: attrs.ngDialogCloseByDocument === 'false' ? false : (attrs.ngDialogCloseByDocument === 'true' ? true : defaults.closeByDocument),
                        closeByEscape: attrs.ngDialogCloseByEscape === 'false' ? false : (attrs.ngDialogCloseByEscape === 'true' ? true : defaults.closeByEscape),
                        overlay: attrs.ngDialogOverlay === 'false' ? false : (attrs.ngDialogOverlay === 'true' ? true : defaults.overlay),
                        preCloseCallback: attrs.ngDialogPreCloseCallback || defaults.preCloseCallback
                    });
                });
            }
        };
    }]);

    return m;
}));
app.factory('Popup', PopupFactory);

PopupFactory.$inject = ["$rootScope", "$compile", '$q', '$document', '$parse'];


function PopupFactory($rootScope, $compile, $q, $document, $parse) {

    return {
        open: open,
        confirm: confirm,
        showSuccess: showSuccess,
        showInfo: showInfo,
        showWarning: showWarning,
        showError: showError
    };

    function confirm(question, confirmFunc) {
        var params = {
            plainText: question,
            scope: $rootScope,
            title: 'Confirmation',
            buttons: [{
                title: 'Yes',
                fn: confirmFunc
            }, {
                title: 'No',
                fn: function(){
                    return true;
                }
            }]
        };
        open(params);
    }

    function showSuccess(msg) {
        var params = {
            plainText: msg,
            scope: $rootScope,
            popupType: 'success',
            title: 'Success'
        };
        open(params);
    }

    function showInfo(msg) {
        var params = {
            plainText: msg,
            scope: $rootScope,
            popupType: 'info',
            title: 'Info'
        };
        open(params);
    }

    function showWarning(msg) {
        var params = {
            plainText: msg,
            scope: $rootScope,
            popupType: 'warning',
            title: 'Warning'
        };
        open(params);
    }

    function showError(msg) {
        var params = {
            plainText: msg,
            scope: $rootScope,
            popupType: 'error',
            title: 'Error'
        };
        open(params);
    }

    function open(params) {
        if (!params) return null;

        var popup = {
            scope: null,
            el: null,
            close: destroy
        };

        var template = '<div style="display: none;" on-close="destroy()" open-now="true" data="data" title="{{title}}" plain-text="{{plainText}}" ' +
            'ac-popup="{{templateUrl}}" popup-class="{{popupClass}}" popup-type="{{popupType}}" scroll-disable="false" popup-wide="{{popupWide}}"' +
            'buttons="buttons" before-close="beforeClose" popup-width="{{popupWidth}}" icon-class="{{iconClass}}"></div>';

        var childScope = popup.scope = params.scope.$new();
        childScope.popupClass = params.plainText ? 'ac_popup_msg' : childScope.popupClass;
        childScope.beforeClose = params.beforeClose || function () {};

        var skipKeys = ['popupClass', 'beforeClose'];
        angular.forEach(params, function (val, key) {
            if (skipKeys.indexOf(key) == -1) {
                childScope[key] = val;
            }
        });

        childScope.destroy = destroy;

        var templateElement = angular.element(template);
        angular.element('body').prepend(templateElement);
        childScope.element = templateElement;
        popup.el = $compile(templateElement)(childScope);

        function destroy() {
            this.element.remove();
            this.$destroy();
        }

        return popup;
    }

}
(function (app) {

    app.factory('Session', Session);

    Session.$inject = ["$routeParams"];

    function Session($routeParams) {
        var self = this;

        self.rootUrl = function () {
            return window.rootUrl;
        };

        self.state = {};

        self.paramsFor = {};

        self.isDebug = !!_app.getQueryParams().debug;

        return self;
    }

})(app);
app.factory('Spinner', ["$window", "$document", "$timeout", "$compile", "$rootScope", function ($window, $document, $timeout, $compile, $rootScope) {

    var template =
        '<div class="vs_spinner_container" ng-show="visible">\
            <div style="background-color: #ffffff;width: 125px;height: 100px;position: relative;top: 50%;left: 50%;border-radius: 10px;margin: -50px 0 0 -63px;padding: 20px 5px;">\
                <div class="vs_showMore">\
                    <div class="vs_spinner"></div>\
                    <div class="vs_spinnerLegend ng-binding">{{msg}}</div>\
                </div>\
            </div>\
        </div>';

    var openedSpinner = null;
    var tasksCount = 0;

    function hide() {
        openedSpinner.scope.safeApply(function () {
            openedSpinner.scope.visible = false;
        });
    }

    function show(spinnerText) {
        tasksCount++;

//        console.log(['spinner show', tasksCount, 'caller', arguments.callee.caller.toString()]);

        if (openedSpinner && openedSpinner.scope.visible == true) {
            // do nothing
        } else if (openedSpinner && openedSpinner.scope.visible == false) {
            openedSpinner.scope.safeApply(function () {
                openedSpinner.scope.visible = true;
                openedSpinner.scope.msg = spinnerText || 'loading...';
            });
        } else {
            var childScope = $rootScope.$new();
            childScope.visible = true;
            childScope.msg = spinnerText || 'loading...';
            makeSpinner(childScope);
        }

//        openedSpinner.scope.msg = spinnerText || 'loading...';
    }

    function done() {
        --tasksCount == 0 && hide()
        //console.log(['spinner done', tasksCount, 'caller', arguments.callee.caller.toString()]);
    }

    function makeSpinner(scope) {
        var element = angular.element($compile(template)(scope));

        openedSpinner = {
            el: element,
            scope: scope
        };

        var body = $document.find('body');
        body.append(element);

        element.on('wheel', function (e) {
            if (openedSpinner.scope.visible == true) {
                e.preventDefault();
            }
        });
    }

    return {
        show: show,
        close: hide,
        done: done
    };
}]);
angular.module('rt.popup', [])
    .factory('Popup', ["$window", "$document", "$timeout", "$compile", "$parse", function ($window, $document, $timeout, $compile, $parse) {
        var openedPopup = null;
        var body = null;
        var backgroundTpl = '<div style="position: fixed;width: 100%;height: 100%;top:0;left: 0;z-index: 100;"></div>',
            template = '<div class="popover"><div ng-include="popupView" onload="$reposition()"></div></div>';
        var scrollLocked = false;

        // Padding towards edges of screen.
        var padding = 10;

        function hidePopup() {
            if (!openedPopup) {
                return;
            }

            var popup = openedPopup;
            openedPopup = null;
            scrollLocked = false;

            $timeout(function () {
                $parse(popup.options.popupHidden)(popup.scope);

                popup.background.unbind('click');
                body.unbind('mousewheel');

                popup.background.hide().remove();
                popup.el.hide().remove();
            });
        }

        function extend(obj, values) {
            for (var key in values) {
                if (!obj[key]) {
                    obj[key] = values[key];
                }
            }
        }

        function showPopup(anchor, scope, attrs) {
            extend(attrs, {
                popupPlacement: 'right',
                popupPlacementFn: null,
                popupClass: '',
                popupShown: '',
                popupHidden: '',
                popupOverlap: '5' // Overlap with anchor element
            });

            scope.popupView = attrs.popupShow;
            scope.hidePopover = hidePopup;

            $timeout(function () {
                makePopup(anchor, scope, attrs);
            });
        }

        function offset(el, options) {
            var rect = el[0].getBoundingClientRect();
            return {
                width: rect.width || el.prop('offsetWidth'),
                height: rect.height || el.prop('offsetHeight'),
                top: rect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
                left: rect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft),
                clientX: options.clientX,
                clientY: options.clientY
            };
        }

        function fixPosition(scope, anchor, element, arrow, options) {
            var popupPosition = null;
            var arrowPosition = null;
            var anchorPoint = null;
            var anchorGeom = offset(anchor, options);

            var placement = options.popupPlacement;

            var fn = options.popupPlacementFn ? $parse(options.popupPlacementFn)(scope) : null;
            if (angular.isFunction(fn)) {
                placement = fn(anchorGeom);
            }

            var maxHeight = $window.innerHeight - 2 * padding;

            var overlap = +options.popupOverlap;

            var minWidth = 0;

            // custom params for vendor popover
            var popupWidth = 1024,
                popupHalfWidth = popupWidth / 2,
                windowCenter = window.innerWidth / 2,
                positionCenterLeft = windowCenter - popupHalfWidth,
                positionLeftLeft = 50,
                positionRightLeft = window.innerWidth - popupWidth - 50,
                paddingVendor = window.innerWidth <= popupWidth ? 0 : padding;
            // ---------------------------------

            // Calculate popup position
            if (placement === 'right') {
                anchorPoint = {
                    top: anchorGeom.top + anchorGeom.height / 2,
                    left: anchorGeom.left + anchorGeom.width - overlap
                };

                popupPosition = {
                    top: anchorPoint.top - element.height() / 2,
                    left: anchorPoint.left
                };

                // Clamp for edge of screen
                popupPosition.top = Math.max(padding, popupPosition.top);
                maxHeight -= popupPosition.top;

                arrowPosition = {
                    top: anchorPoint.top - popupPosition.top
                };
            } else if (placement === 'left') {
                anchorPoint = {
                    top: anchorGeom.top + anchorGeom.height / 2,
                    left: anchorGeom.left + overlap - 2
                };

                popupPosition = {
                    top: anchorPoint.top - element.height() / 2,
                    right: $window.innerWidth - anchorPoint.left
                };

                // Clamp for edge of screen
                popupPosition.top = Math.max(padding, popupPosition.top);
                maxHeight -= popupPosition.top;

                arrowPosition = {
                    top: anchorPoint.top - popupPosition.top
                };
            } else if (placement === 'bottom') {
                anchorPoint = {
                    top: anchorGeom.top + anchorGeom.height,
                    left: anchorGeom.left + anchorGeom.width / 2
                };

                popupPosition = {
                    top: anchorPoint.top - overlap,
                    left: anchorPoint.left - element.width() / 2
                };

                // Clamp for edge of screen
                popupPosition.left = Math.max(padding, popupPosition.left);
                maxHeight -= popupPosition.top;

                arrowPosition = {
                    left: anchorPoint.left - popupPosition.left
                };
            } else if (placement === 'bottom-left') {
                anchorPoint = {
                    top: anchorGeom.top + anchorGeom.height,
                    left: anchorGeom.left + element.width() / 2
                };

                popupPosition = {
                    top: anchorPoint.top - overlap,
                    left: anchorPoint.left - element.width() / 2
                };

                // Clamp for edge of screen
                popupPosition.left = Math.max(padding, popupPosition.left);
                maxHeight -= popupPosition.top;

                // Update placement so we get the class name
                placement = 'bottom';

                arrowPosition = {
                    left: anchorPoint.left - popupPosition.left
                };
            } else if (placement === 'top') {
                anchorPoint = {
                    top: anchorGeom.top - element.outerHeight(),
                    left: anchorGeom.left + anchorGeom.width / 2
                };

                popupPosition = {
                    top: anchorPoint.top + overlap,
                    left: anchorPoint.left - element.width() / 2
                };

                // Clamp for edge of screen
                popupPosition.left = Math.max(padding, popupPosition.left);
                maxHeight -= popupPosition.top;

                arrowPosition = {
                    left: anchorPoint.left - popupPosition.left
                };
            } else if (placement === 'bottom-custom') {
                anchorPoint = {
                    top: anchorGeom.top + anchorGeom.height,
                    left: anchorGeom.left + anchorGeom.width / 2
                };

                var isOutOfRangeLeft = anchorPoint.left - element.width() < 0,
                    isOutOfRangeRight = anchorPoint.left + element.width() > window.innerWidth,
                    popupPositionLeft = 0;

                if (isOutOfRangeLeft == true || isOutOfRangeRight == true) {
                    popupPositionLeft = anchorPoint.left - element.width();
                } else {
                    popupPositionLeft = anchorPoint.left - element.width() / 2;
                }

                popupPosition = {
                    top: anchorPoint.top - overlap,
                    left: popupPositionLeft
                };

                // Clamp for edge of screen
                popupPosition.left = Math.max(padding, popupPosition.left);
                maxHeight -= popupPosition.top;

                var arrowPositionLeft = 0;
                if (isOutOfRangeLeft == true) {
                    arrowPositionLeft = anchorGeom.left + anchorGeom.width - 20;
                } else if (isOutOfRangeRight == true) {
                    arrowPositionLeft = anchorGeom.left - popupPosition.left + 7;
                } else {
                    arrowPositionLeft = anchorPoint.left - popupPosition.left;
                }

                arrowPosition = {
                    left: arrowPositionLeft
                };

                // Update placement so we get the class name
                placement = 'bottom';

            } else if (placement === 'top-custom') {
                anchorPoint = {
                    top: anchorGeom.top - element.outerHeight(),
                    left: anchorGeom.left + anchorGeom.width / 2
                };

                var isOutOfRangeLeft = anchorPoint.left - element.width() < 0,
                    isOutOfRangeRight = anchorPoint.left + element.width() > window.innerWidth,
                    popupPositionLeft = 0;

                if (isOutOfRangeLeft == true || isOutOfRangeRight == true) {
                    popupPositionLeft = anchorPoint.left - element.width();
                } else {
                    popupPositionLeft = anchorPoint.left - element.width() / 2;
                }

                popupPosition = {
                    top: anchorPoint.top + overlap,
                    left: popupPositionLeft
                };

                // Clamp for edge of screen
                popupPosition.left = Math.max(padding, popupPosition.left);
                maxHeight -= popupPosition.top;

                var arrowPositionLeft = 0;
                if (isOutOfRangeLeft == true) {
                    arrowPositionLeft = anchorGeom.left + anchorGeom.width - 20;
                } else if (isOutOfRangeRight == true) {
                    arrowPositionLeft = anchorGeom.left - popupPosition.left + 7;
                } else {
                    arrowPositionLeft = anchorPoint.left - popupPosition.left;
                }

                arrowPosition = {
                    left: arrowPositionLeft
                };

                placement = 'top';
            } else if (placement === 'bottom-vendor') {

                anchorPoint = {
                    top: anchorGeom.top + anchorGeom.height,
                    left: anchorGeom.left + anchorGeom.width / 2
                };

                popupPosition = {
                    top: anchorPoint.top - overlap,
                    left: anchorPoint.left < positionCenterLeft ?
                        positionLeftLeft :
                        anchorPoint.left < windowCenter + popupHalfWidth ? positionCenterLeft : positionRightLeft
                };

                // Clamp for edge of screen
                popupPosition.left = Math.max(paddingVendor, popupPosition.left);

                arrowPosition = {
                    left: anchorPoint.left - popupPosition.left
                };

                // Update placement so we get the class name
                placement = 'bottom';
                minWidth = 1024;

            } else if (placement === 'top-vendor') {

                anchorPoint = {
                    top: anchorGeom.top - element.outerHeight(),
                    left: anchorGeom.left + anchorGeom.width / 2
                };

                popupPosition = {
                    top: anchorPoint.top + overlap,
                    left: anchorPoint.left < positionCenterLeft ?
                        positionLeftLeft :
                        anchorPoint.left < windowCenter + popupHalfWidth ? positionCenterLeft : positionRightLeft
                };

                // Clamp for edge of screen
                popupPosition.left = Math.max(paddingVendor, popupPosition.left);

                arrowPosition = {
                    left: anchorPoint.left - popupPosition.left
                };

                placement = 'top';
                minWidth = 1024;
            } else {
                throw new Error('Unsupported placement ' + placement);
            }

            element.removeClass('left right bottom top');
            element.addClass(placement);
            element.css({
                top: popupPosition.top !== undefined ? popupPosition.top + 'px' : 'initial',
                left: popupPosition.left !== undefined ? popupPosition.left + 'px' : 'initial',
                right: popupPosition.right !== undefined ? popupPosition.right + 'px' : 'initial',
                display: 'block',
//                maxHeight: maxHeight,
                'min-width': minWidth
            });

            var header = element.find('.popover-title');
            var content = element.find('.popover-content');
            var footer = element.find('.popover-footer');
            content.css({
                // Need to figure out where this 4 comes from.
                maxHeight: maxHeight - footer.outerHeight() - header.outerHeight() - 4,
                overflow: 'auto'
            });

            if (arrowPosition) {
                arrow.css(arrowPosition);
            }

            element.removeClass('hide');

            $parse(options.popupShown)(scope);
        }

        function makePopup(anchor, scope, options) {
            var element = $compile(template)(scope);
            var background = angular.element(backgroundTpl);

            openedPopup = {
                el: element,
                options: options,
                scope: scope,
                background: background
            };

            body = $document.find('body');
            body.append(background);
            body.append(element);

            background.bind('click', function(){
                hidePopup();
            });

            // Add arrow
            var arrow = $('<div />', { 'class': 'arrow' });
            element.children('.arrow').remove();
            element.append(arrow);

            body.bind('mousewheel', function (e) {
                if (scrollLocked == true) {
//                    var $div = $('div');
//                    $div.scrollTop($div.scrollTop() - e.originalEvent.wheelDelta);
//                    return false;
                    //e.preventDefault();
                }
            });

            scope.$reposition = function () {
                // add extra class here, to ensure that the width calculation takes this into account
                var extra_class = options.popupClass;
                if (extra_class) {
                    element.addClass(extra_class);
                }

                $timeout(function () {
                    scrollLocked = true;
                    fixPosition(scope, anchor, element, arrow, options);
                });
            };
        }

        return {
            show: showPopup,
            close: hidePopup
        };
    }])

    .directive('popupShow', ["Popup", "$parse", "$timeout", function (Popup, $parse, $timeout) {
        return {
            restrict: 'AC',
            scope: true,
            link: function (scope, element, attrs) {
                scope.popover = Popup;

                scope.$watch(attrs.popupRecord, function (record) {
                    scope.record = record;
                });

                element.click(function (event) {
                    $timeout(function () {
                        Popup.close();

                        var shouldShow = $parse(attrs.popupIf || 'true');
                        if (shouldShow(scope)) {
                            attrs.clientX = event.clientX;
                            attrs.clientY = event.clientY;
                            Popup.show(element, scope, attrs);
                        }
                    });
                });
            }
        };
    }])

    .directive('popupAutoShow', ["Popup", "$parse", function (Popup, $parse) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                scope.$watch(attrs.popupAutoShow, function (val) {
                    if (val) {
                        Popup.close();
                        var shouldShow = $parse(attrs.popupIf || 'true');
                        if (shouldShow(scope)) {
                            Popup.show(element, scope, attrs);
                        }
                    }
                });
            }
        };
    }]);

app.directive('dynamicContent', [function () {
    return{
        require: ['^?mdTabs', '^?mdTab'],
        terminal: true,
//        scope: {
//            canLoad: '=canLoad'
//        },
        link: function link(scope, element, attrs, ctrl) {

            console.log(['mdTab', ctrl, scope, attrs.dynamicContent, scope.$eval(attrs.dynamicContent)])

            scope.$watch('canLoad', function () {
                console.log('$watch', arguments);
            })
        },
        controller: function () {
            console.log('controller', arguments);
        }
    }
}])
app.directive('keyPress', function () {
    return function (scope, element, attrs) {
        var options = (new Function('return ' + attrs.keyPress))();

        element.bind("keydown keypress", function (event) {
            if (event.which === options.keyCode) {
                scope.$apply(function () {
                    scope.$eval(options.fn, {'event': event});
                });

                event.preventDefault();
            }
        });
    };
});
app.directive('acPopup', PopupDirectory);

PopupDirectory.$inject = ["$rootScope", "$compile", '$q', '$document', '$parse'];


function PopupDirectory($rootScope, $compile, $q, $document, $parse) {

    var template = '\
        <div class="popoverBackground "  ng-show="visible" ng-click="close()"></div>\
        <table id="popupContainer">\
            <tr><td>\
                <div class="vs_popupWhite" ng-class="{\'vs_redWarn\' : (popupType == \'warning\' || popupType == \'error\'), \'{{popupClass}}\' : popupClass, \'{{popupWide}}\' : popupWide}">\
                    <div class="vs_popupWhiteHeader">\
                        <div class="vs_popupWhiteHeaderIcon" ng-class="iconClass"></div>\
                        <h4>{{title || "Message"}}\
                            <span></span>\
                        </h4>\
                    </div>\
                    <button class="popoverCloseButton vs_popupCloseBtn" ng-click="close()">Close</button>\
                    \
                    <div ng-include="includeUrl"></div>\
                    \
                    <div class="vs_popupWhiteFooter">\
                        <a href="javascript:void(0)" title="DesignersAxis" class="vs_background_logo" ng-if="popupType != \'warning\' && popupType != \'error\'"></a>\
                        <div class="popupFooterButtons" ng-show="popup.buttons.length > 0" ng-class="{\'vs_right\' : popupType != \'warning\' && popupType != \'error\'}">\
                            <button ng-click="button.fn()" ng-class="button.class" ng-repeat="button in popup.buttons">{{button.title}}</button>\
                        </div>\
                    </div>\
                </div>\
            </td></tr>\
        </table>';

    function link(scope, element, attrs, ctrl) {

        scope.canShowDialogButtons = attrs.okFn || attrs.cancelFn;
        scope.includeUrl = _app.urlCombine(window.rootUrl, attrs.acPopup);

        var createChildScope = function () {
            var childScope = scope.$new();

            childScope.popupType = scope.popupType;
            childScope.onClose = scope.onClose;
            childScope.popupClass = scope.popupClass;

            childScope.close = function () {

                popup.scope.popup.onClose && popup.scope.popup.onClose(function (returnData) {
                    popup.scope.beforeClose && popup.scope.beforeClose()(returnData);
                });

                scrollOff(popup.popupElement);

                popup.scope.onClose();
                popup.popupElement.remove();
                popup.scope.$destroy();
                popup.popupElement = undefined;

                popup = {
                    scope: createChildScope()
                };
            };

            childScope.okClick = function () {
                childScope.okFn && childScope.okFn();
                childScope.close();
            };

            childScope.cancelClick = function () {
                childScope.cancelFn && childScope.cancelFn();
                childScope.close();
            };

            childScope.popup = {
                data: scope.data,
                scope: childScope,
                buttons: scope.buttons || [],
                close: childScope.close,
                onClose: null
            };

            scope.$watch(function () {
                return childScope.popup.buttons;
            }, function (newButtons) {
                angular.forEach(wrapButtonsFn(newButtons), function (button) {
                    childScope.popup.buttons.push(button);
                });
            }, true);

            function wrapButtonsFn(buttons) {
                var newButtons = [];
                angular.forEach(buttons, function (button) {

                    if (button.$wrapped) return;

                    if (button.fn) {
                        var buttonFnLink = button.fn;
                        button.fn = function () {
                            console.log('button.fn 1');
                            var result = buttonFnLink();

                            if (result.then) {
                                result.success(function () {
                                    childScope.close();
                                })
                            } else if (result == true) {
                                childScope.close();
                            }
                        }
                    } else if (button.fnString) {
                        button.fn = function () {
                            var fn = $parse(button.fnString)(scope.$parent);
                            fn && fn();
                            childScope.close();
                        };
                    } else {
                        button.fn = function () {
                            childScope.close();
                            return true;
                        }
                    }

                    button.$wrapped = true;
                });

                return newButtons;
            }


            return childScope;
        };

        var popup = {
            scope: createChildScope()
        };

        scope.$watch(function () {
            return scope.data;
        }, function (newVal) {
            if (newVal) {
                popup.scope.popup.data = newVal;
            }
        }, true);

        var body = $document.find('body');

        var openFn = function () {
            popup.scope.visible = true;

            if (!popup.popupElement) {
                popup.popupElement = $compile(scope.plainText ?
                    updateTemplateForPlainTextMode(template) : template)(popup.scope);

                if (!scope.openNow && scope.$root.$$phase != '$apply' && scope.$root.$$phase != '$digest') popup.scope.$apply();

                body.append(popup.popupElement);

                scrollON(popup.popupElement);
            }
        };

        if (scope.openNow) {
            openFn();
        } else {
            element.on('click', function () {
                if (attrs.beforeShow) {

                    var callback = function () {

                        var result = scope.$parent.$eval(attrs.beforeShow);
                        var defer = $q.defer();
                        var promise = defer.promise;

                        if (result && result.then) {
                            promise = result;
                        } else if (!!result == true) {
                            defer.resolve();
                        } else {
                            defer.reject();
                        }

                        return promise;
                    };

                    callback().success(function () {
                        openFn();
                    });
                } else {
                    openFn()
                }
            });
        }

        function updateTemplateForPlainTextMode(template) {
            return template.replace(
                '<div ng-include="includeUrl"></div>',
                '<div class="popup_msg_container ac_plain_text">{{plainText}}</div>'
            );
        }

        function scrollOff(element) {
            if (scope.scrollDisable) {
                element.off('wheel');
            }
        }

        function scrollON(element) {
            if (scope.scrollDisable == true) {
                element.on('wheel', function (e) {
                    e.preventDefault();
                });
            }
        }
    }

    return {
        link: link,
        scope: {
            data: '=',
            title: '@',
            iconClass: '@',
            okFn: '&',
            cancelFn: '&',
            popupType: '@',
            buttons: "=",
            scrollDisable: '=',
            plainText: '@',
            openNow: '=',
            onClose: '&',
            beforeClose: '&',
            popupClass: '@',
            popupWide: '@',
            beforeShow: '&'
        }
    }
}
app.directive('scrolly', function () {
    return {
        restrict: 'A',
        link: function (scope, element, attrs) {
            var raw = element[0];
            element.bind('scroll', function () {
                if (raw.scrollTop + raw.offsetHeight > raw.scrollHeight) {
                    scope.$apply(attrs.scrolly);
                }
            });
        }
    };
});
var ShowLargeImageDirective = function ($document, $compile) {
    var template = '\
        <div class="popoverBackground vs_showBigImage" ng-show="visible"></div>\
		<table ng-click="close()">\
		<tr><td>\
        <div class="vs_popupWhite vs_dynamic">\
            <div class="vs_popupWhiteHeader">\
                <h4>Image View\
                    <span></span>\
                </h4>\
            </div>\
            <button class="popoverCloseButton vs_popupCloseBtn" ng-click="close()">Close</button>\
            <div class="vs_popup_large_img" ng-show="visible">\
				<img src="{{showLargeImage}}">\
			</div>\
            <div class="vs_popupWhiteFooter">\
                <a href="javascript:void(0)" title="DesignersAxis" class="vs_background_logo"></a>\
                <div ng-if="canShowDialogButtons" class="vs_right">\
                    <button ng-click="okClick()">Ok</button>\
                    <button class="vs_nonDefault" ng-click="cancelClick()">Cancel</button>\
                </div>\
            </div>\
        </div>\
		</td></tr>\
		</table>';

    var linkFn = function (scope, element, attrs) {
        var body = $document.find('body');
        var imagePopup = {};

        element.addClass('vs_cursor_pointer');

        var createChildScope = function () {
            var childScope = scope.$new();

            childScope.visible = false;
            childScope.showLargeImage = scope.showLargeImage;
            childScope.close = function () {
                imagePopup.el.off('wheel');
                imagePopup.el.remove();
                imagePopup.scope.$destroy();
                imagePopup.el = undefined;

                imagePopup = {
                    scope: createChildScope()
                };
            };

            return childScope;
        };

        imagePopup = {
            scope: createChildScope()
        };

        element.on('click', function () {
            imagePopup.scope.visible = true;

            if (!imagePopup.el) {
                imagePopup.el = $compile(template)(imagePopup.scope);
                imagePopup.scope.$apply();

                body.append(imagePopup.el);

                imagePopup.el.on('wheel', function (e) {
                    e.preventDefault();
                })
            }
        });
    };

    return {
        scope: {
            showLargeImage: '='
        },
        link: linkFn
    }
};

ShowLargeImageDirective.$inject = ['$document', '$compile'];

app.directive('showLargeImage', ShowLargeImageDirective);
app.directive("textSpinner", [function () {
    var tpl = '<div class="vs_showMore" ng-show="visible"><div class="vs_spinner"></div><div class="vs_spinnerLegend">{{text}}</div></div>';

    return {
        restrict: "E",
        template: tpl,
        scope: {
            text: "=text",
            visible: "=visible"
        }
    }
}]);
app.directive('stopScrollPropagation', stopScrollPropagation);

stopScrollPropagation.$inject = [];

function stopScrollPropagation() {

    function linkFn(scope, element, attr) {
        element.on('wheel', function (e) {
            stopScrollProp(e)
        });
        element.on('touchmove', function (e) {
            stopScrollProp(e)
        });
        function stopScrollProp(e) {
            e.stopImmediatePropagation();

            if (element[0].offsetHeight + element[0].scrollTop >= element[0].scrollHeight && e.originalEvent.wheelDelta < 0 ||
                element[0].scrollTop == 0 && e.originalEvent.wheelDelta > 0) {
                e.preventDefault();
            }
        }
    }

    return {
        scope: {
            preventEvent: '@'
        },
        link: linkFn
    }
}
app.directive('tabButton', TabButton);

function TabButton($compile, $controller) {
    var mdTabItem;
    return {
        require: '^?mdTabs',
        terminal: true,
        compile: function (element, attr) {

            var wrapper = element.parent().parent()[0],
                canvas = wrapper.getElementsByTagName('md-tabs-canvas')[0];

            mdTabItem = angular.element('<div class="vs_tabButton vs_cursor_pointer"></div>');
            if (attr['onClick']) mdTabItem = angular.element('<div class="vs_tabButton vs_cursor_pointer" on-click="'+ attr['onClick'] +'"></div>')
            mdTabItem.append(element.html());
            angular.element(canvas).append(mdTabItem);

            return postLink;
        },
        scope: {
            active: '=?mdActive',
            disabled: '=?ngDisabled',
            select: '&?mdOnSelect',
            deselect: '&?mdOnDeselect',
            onClick: '&'
        }
    };

    function postLink(scope, element, attr, ctrl) {
        ctrl.scope.$watch('selectedIndex', function () {
            // do nothing
        });
        mdTabItem.on('click', scope.onClick);
    }
}

TabButton.$inject = ["$compile", "$controller"];
app.directive('tabClick', ["$rootScope", function ($rootScope) {
    return{
        link: function link(scope, element, attrs, ctrl) {
            var parent = element.parent();
            if (parent == null || parent.length == 0 || parent[0].nodeName != "MD-TAB-ITEM" || !attrs.tabClick) {
                return;
            }

            $rootScope.appCtrl && $rootScope.appCtrl.clickTabAdd({
                el: parent[0],
                id: attrs.tabClick
            });

            if (!$rootScope.appCtrl) {
                console.error('Could not add tab. $rootScope.appCtrl is ', $rootScope.appCtrl);
            }
        }
    }
}]);
app.directive('userAvatar', function() {
    return {
        replace: true,
        template: '<svg class="user-avatar" viewBox="0 0 128 128" height="64" width="64" pointer-events="none" display="block" > <path fill="#FF8A80" d="M0 0h128v128H0z"/> <path fill="#FFE0B2" d="M36.3 94.8c6.4 7.3 16.2 12.1 27.3 12.4 10.7-.3 20.3-4.7 26.7-11.6l.2.1c-17-13.3-12.9-23.4-8.5-28.6 1.3-1.2 2.8-2.5 4.4-3.9l13.1-11c1.5-1.2 2.6-3 2.9-5.1.6-4.4-2.5-8.4-6.9-9.1-1.5-.2-3 0-4.3.6-.3-1.3-.4-2.7-1.6-3.5-1.4-.9-2.8-1.7-4.2-2.5-7.1-3.9-14.9-6.6-23-7.9-5.4-.9-11-1.2-16.1.7-3.3 1.2-6.1 3.2-8.7 5.6-1.3 1.2-2.5 2.4-3.7 3.7l-1.8 1.9c-.3.3-.5.6-.8.8-.1.1-.2 0-.4.2.1.2.1.5.1.6-1-.3-2.1-.4-3.2-.2-4.4.6-7.5 4.7-6.9 9.1.3 2.1 1.3 3.8 2.8 5.1l11 9.3c1.8 1.5 3.3 3.8 4.6 5.7 1.5 2.3 2.8 4.9 3.5 7.6 1.7 6.8-.8 13.4-5.4 18.4-.5.6-1.1 1-1.4 1.7-.2.6-.4 1.3-.6 2-.4 1.5-.5 3.1-.3 4.6.4 3.1 1.8 6.1 4.1 8.2 3.3 3 8 4 12.4 4.5 5.2.6 10.5.7 15.7.2 4.5-.4 9.1-1.2 13-3.4 5.6-3.1 9.6-8.9 10.5-15.2M76.4 46c.9 0 1.6.7 1.6 1.6 0 .9-.7 1.6-1.6 1.6-.9 0-1.6-.7-1.6-1.6-.1-.9.7-1.6 1.6-1.6zm-25.7 0c.9 0 1.6.7 1.6 1.6 0 .9-.7 1.6-1.6 1.6-.9 0-1.6-.7-1.6-1.6-.1-.9.7-1.6 1.6-1.6z"/> <path fill="#E0F7FA" d="M105.3 106.1c-.9-1.3-1.3-1.9-1.3-1.9l-.2-.3c-.6-.9-1.2-1.7-1.9-2.4-3.2-3.5-7.3-5.4-11.4-5.7 0 0 .1 0 .1.1l-.2-.1c-6.4 6.9-16 11.3-26.7 11.6-11.2-.3-21.1-5.1-27.5-12.6-.1.2-.2.4-.2.5-3.1.9-6 2.7-8.4 5.4l-.2.2s-.5.6-1.5 1.7c-.9 1.1-2.2 2.6-3.7 4.5-3.1 3.9-7.2 9.5-11.7 16.6-.9 1.4-1.7 2.8-2.6 4.3h109.6c-3.4-7.1-6.5-12.8-8.9-16.9-1.5-2.2-2.6-3.8-3.3-5z"/> <circle fill="#444" cx="76.3" cy="47.5" r="2"/> <circle fill="#444" cx="50.7" cy="47.6" r="2"/> <path fill="#444" d="M48.1 27.4c4.5 5.9 15.5 12.1 42.4 8.4-2.2-6.9-6.8-12.6-12.6-16.4C95.1 20.9 92 10 92 10c-1.4 5.5-11.1 4.4-11.1 4.4H62.1c-1.7-.1-3.4 0-5.2.3-12.8 1.8-22.6 11.1-25.7 22.9 10.6-1.9 15.3-7.6 16.9-10.2z"/> </svg>'
    };
});

(function(app){

    app.controller('ContactUsViewController', ContactUsViewController);

    ContactUsViewController.$inject = ['$scope', '$rootScope', '$state', 'Session'];

    function ContactUsViewController($scope, $rootScope, $state, Session) {

        var vm = this;
        vm.scope = $scope;
        vm.translations = Session.state['Translations'];

        vm.init = function () {

        };

        vm.init();
    }

})(app);

(function(app){

    app.controller('HelpViewController', HelpViewController);

    HelpViewController.$inject = ['$scope', '$rootScope', '$state'];

    function HelpViewController($scope, $rootScope, $state) {

        var vm = this;
        vm.scope = $scope;
        $rootScope.rootCtrl = vm;

        vm.init = function () {

        };

        vm.init();
    }

})(app);

(function(app){

    app.controller('MainViewController', MainViewController);

    MainViewController.$inject = ['$scope', '$rootScope', '$state', 'Session'];

    function MainViewController($scope, $rootScope, $state, Session) {

        var vm = this;
        vm.scope = $scope;
        vm.state = Session.state['MainViewController'] = Session.state['MainViewController'] || {isInited: false};
        vm.translations = Session.state['Translations'];

        vm.init = function () {

        };

        if(!vm.state.isInited) {
            vm.init();
            vm.state.isInited = true;
        }
    }

})(app);

(function(app){

    app.controller('ModelsViewController', ModelsViewController);

    ModelsViewController.$inject = ['$scope', '$rootScope', '$state', 'Session', 'DB'];

    function ModelsViewController($scope, $rootScope, $state, Session, DB) {

        var vm = this;
        vm.scope = $scope;
        vm.state = Session.state['ModelsViewController'] = Session.state['ModelsViewController'] || {isInited: false};
        vm.state.filter = {
            executioner: '',
            room: '',
            style:'',
            gamma:'',
            tone: '',
            main_color:'',
            accent_color: '',
            material: ''
        };

        vm.init = function () {
            DB.getModels(vm.state.filter, function(res) {
                if(res) {
                    vm.state.models = res.data;
                } else {

                }
            });
        };

        if (!vm.state.isInited) {
            vm.init();
            vm.state.isInited = true;
        }

        vm.getImgPath = function (url) {
            var result = window.location.origin + '/project_data/models/' + url + '.jpg';
            return result;
        };
    }

})(app);

(function(app){

    app.controller('PopupNewProjectController', PopupNewProjectController);

    PopupNewProjectController.$inject = ['$scope', '$rootScope', '$state', '$mdDialog'];

    function PopupNewProjectController($scope, $rootScope, $state, $mdDialog) {

        var vm = this;
        vm.scope = $scope;
        vm.scope.projectTitle = "";

        vm.init = function () {
            console.log(["init", vm.scope]);
        };

        vm.init();

        vm.scope.cancel = function() {
            $mdDialog.cancel();
        };

        vm.scope.create = function() {
            $mdDialog.hide(vm.scope.projectTitle);
        };

    }

})(app);
(function(app){

    app.controller('PopupNewTaskController', PopupNewTaskController);

    PopupNewTaskController.$inject = ['$scope', '$rootScope', '$state', '$mdDialog'];

    function PopupNewTaskController($scope, $rootScope, $state, $mdDialog) {

        var vm = this;
        vm.scope = $scope;
        vm.scope.taskTitle = "";
        vm.scope.needRedirect = false;

        vm.init = function () {
            console.log(["init", vm.scope]);
        };

        vm.init();

        vm.scope.cancel = function() {
            $mdDialog.cancel();
        };

        vm.scope.create = function() {
            $mdDialog.hide({
                title: vm.scope.taskTitle,
                redirect: vm.scope.needRedirect
            });
        };

    }

})(app);
(function(app){

    app.controller('PopupSignInController', PopupSignInController);

    PopupSignInController.$inject = ['$scope', '$rootScope', '$state', '$mdDialog', 'DB'];

    function PopupSignInController($scope, $rootScope, $state, $mdDialog, DB) {

        var vm = this;
        vm.scope = $scope;

        vm.scope.userEmail = "";
        vm.scope.userPass = "";
        vm.scope.loginError = "";

        vm.init = function () {
            console.log(["init", vm.scope]);
        };

        vm.init();

        vm.scope.cancel = function() {
            $mdDialog.cancel();
        };

        vm.scope.signin = function() {
            var params = {
                email: vm.scope.userEmail,
                pass: vm.scope.userPass
            };

            DB.login(params, function(res) {
                if(res && res.data.success) {
                    window.location.reload();
                } else {
                    vm.scope.loginError = "Error";
                }
            });

        };
    }

})(app);
(function(app){

    app.controller('PopupSignUpController', PopupSignUpController);

    PopupSignUpController.$inject = ['$scope', '$rootScope', '$state', '$mdDialog'];

    function PopupSignUpController($scope, $rootScope, $state, $mdDialog) {

        var vm = this;
        vm.scope = $scope;
        vm.scope.projectTitle = "";

        vm.init = function () {
            console.log(["init", vm.scope]);
        };

        vm.init();

        vm.scope.cancel = function() {
            $mdDialog.cancel();
        };

        vm.scope.create = function() {
            $mdDialog.hide(vm.scope.projectTitle);
        };

    }

})(app);
(function(app){

    app.controller('PortfolioViewController', PortfolioViewController);

    PortfolioViewController.$inject = ['$scope', '$rootScope', '$state', 'Session', 'DB'];

    function PortfolioViewController($scope, $rootScope, $state, Session, DB) {

        var vm = this;
        vm.scope = $scope;
        vm.state = Session.state['PortfolioViewController'] = Session.state['PortfolioViewController'] || {isInited: false};
        vm.translations = Session.state['Translations'];

        vm.init = function () {

            if(!vm.state.activeTab) {
                vm.state.activeTab = 'All';
            }

            if(!vm.state.currentPage) {
                vm.state.currentPage = 1;
            }

            getPortfolio();
            vm.state.images = [];
        };

        if (!vm.state.isInited) {
            vm.init();
            vm.state.isInited = true;
        }


        vm.onChangeTab = function () {
            getPortfolio();
        };

        function getPortfolio() {
            var params = {
                tab: vm.state.activeTab,
                page: vm.state.currentPage
            };

            DB.getPortfolio(params, function(res) {
                if(res) {

                } else {

                }
            });
        }

        vm.COLORS = ['#ffebee', '#ffcdd2', '#ef9a9a', '#e57373', '#ef5350', '#f44336', '#e53935', '#d32f2f', '#c62828', '#b71c1c', '#ff8a80', '#ff5252', '#ff1744', '#d50000', '#f8bbd0', '#f48fb1', '#f06292', '#ec407a', '#e91e63', '#d81b60', '#c2185b', '#ad1457', '#880e4f', '#ff80ab', '#ff4081', '#f50057', '#c51162', '#e1bee7', '#ce93d8', '#ba68c8', '#ab47bc', '#9c27b0', '#8e24aa', '#7b1fa2', '#4a148c', '#ea80fc', '#e040fb', '#d500f9', '#aa00ff', '#ede7f6', '#d1c4e9', '#b39ddb', '#9575cd', '#7e57c2', '#673ab7', '#5e35b1', '#4527a0', '#311b92', '#b388ff', '#7c4dff', '#651fff', '#6200ea', '#c5cae9', '#9fa8da', '#7986cb', '#5c6bc0', '#3f51b5', '#3949ab', '#303f9f', '#283593', '#1a237e', '#8c9eff', '#536dfe', '#3d5afe', '#304ffe', '#e3f2fd', '#bbdefb', '#90caf9', '#64b5f6', '#42a5f5', '#2196f3', '#1e88e5', '#1976d2', '#1565c0', '#0d47a1', '#82b1ff', '#448aff', '#2979ff', '#2962ff', '#b3e5fc', '#81d4fa', '#4fc3f7', '#29b6f6', '#03a9f4', '#039be5', '#0288d1', '#0277bd', '#01579b', '#80d8ff', '#40c4ff', '#00b0ff', '#0091ea', '#e0f7fa', '#b2ebf2', '#80deea', '#4dd0e1', '#26c6da', '#00bcd4', '#00acc1', '#0097a7', '#00838f', '#006064', '#84ffff', '#18ffff', '#00e5ff', '#00b8d4', '#e0f2f1', '#b2dfdb', '#80cbc4', '#4db6ac', '#26a69a', '#009688', '#00897b', '#00796b', '#00695c', '#a7ffeb', '#64ffda', '#1de9b6', '#00bfa5', '#e8f5e9', '#c8e6c9', '#a5d6a7', '#81c784', '#66bb6a', '#4caf50', '#43a047', '#388e3c', '#2e7d32', '#1b5e20', '#b9f6ca', '#69f0ae', '#00e676', '#00c853', '#f1f8e9', '#dcedc8', '#c5e1a5', '#aed581', '#9ccc65', '#8bc34a', '#7cb342', '#689f38', '#558b2f', '#33691e', '#ccff90', '#b2ff59', '#76ff03', '#64dd17', '#f9fbe7', '#f0f4c3', '#e6ee9c', '#dce775', '#d4e157', '#cddc39', '#c0ca33', '#afb42b', '#9e9d24', '#827717', '#f4ff81', '#eeff41', '#c6ff00', '#aeea00', '#fffde7', '#fff9c4', '#fff59d', '#fff176', '#ffee58', '#ffeb3b', '#fdd835', '#fbc02d', '#f9a825', '#f57f17', '#ffff8d', '#ffff00', '#ffea00', '#ffd600', '#fff8e1', '#ffecb3', '#ffe082', '#ffd54f', '#ffca28', '#ffc107', '#ffb300', '#ffa000', '#ff8f00', '#ff6f00', '#ffe57f', '#ffd740', '#ffc400', '#ffab00', '#fff3e0', '#ffe0b2', '#ffcc80', '#ffb74d', '#ffa726', '#ff9800', '#fb8c00', '#f57c00', '#ef6c00', '#e65100', '#ffd180', '#ffab40', '#ff9100', '#ff6d00', '#fbe9e7', '#ffccbc', '#ffab91', '#ff8a65', '#ff7043', '#ff5722', '#f4511e', '#e64a19', '#d84315', '#bf360c', '#ff9e80', '#ff6e40', '#ff3d00', '#dd2c00', '#d7ccc8', '#bcaaa4', '#795548', '#d7ccc8', '#bcaaa4', '#8d6e63', '#eceff1', '#cfd8dc', '#b0bec5', '#90a4ae', '#78909c', '#607d8b', '#546e7a', '#cfd8dc', '#b0bec5', '#78909c'];
        vm.colorTiles = (function() {
            var tiles = [];
            for (var i = 0; i < 46; i++) {
                tiles.push({
                    color: randomColor(),
                    colspan: randomSpan(),
                    rowspan: randomSpan()
                });
            }
            return tiles;
        })();

        function randomColor () {
            return vm.COLORS[Math.floor(Math.random() * vm.COLORS.length)];
        }

        function randomSpan () {
            var r = Math.random();
            if (r < 0.8) {
                return 1;
            } else if (r < 0.9) {
                return 2;
            } else {
                return 3;
            }
        }

        vm.showMore = function () {

        }

    }

})(app);

(function(app){

    app.controller('ProfileViewController', ProfileViewController);

    ProfileViewController.$inject = ['$scope', '$rootScope', '$state', '$stateParams', 'Session', 'DB'];

    function ProfileViewController($scope, $rootScope, $state, $stateParams, Session, DB) {

        var vm = this;
        vm.scope = $scope;
        vm.state = Session.state['ProfileViewController'] = Session.state['ProfileViewController'] || {isInited: false};

        vm.init = function () {

            var urlParams = JSON.parse(JSON.stringify($stateParams)) || {};
            DB.getProfileDetails(urlParams.id, function (res) {
                console.log(res);
                if(res) {
                    if(res.data.success) {
                        vm.state.profile = res.data.profile;
                    } else {

                    }
                }
            });
        };

        if (!vm.state.isInited) {
            vm.init();
            vm.state.isInited = true;
        }

        vm.saveProfile = function () {

            DB.saveProfileDetails(vm.state.profile, function(res){
                if(res){

                } else {

                }
            })
        };

        vm.getProjectUpdates = function () {
            //TODO DB.getProjectUpdates
        };

    }

})(app);

(function (app) {

    app.controller('ProjectViewController', ProjectViewController);

    ProjectViewController.$inject = ['$scope', '$rootScope', '$state', 'Session', 'DB', '$stateParams', 'Upload', '$mdDialog'];

    function ProjectViewController($scope, $rootScope, $state, Session, DB, $stateParams, Upload, $mdDialog) {

        var vm = this;
        vm.scope = $scope;
        vm.state = Session.state['ProjectViewController'] = Session.state['ProjectViewController'] || {isInited: false};
        //vm.state.files;

        vm.state.newMessageData = {
            message: "",
            clientRights: true
        };

        vm.init = function () {
            var params = JSON.parse(JSON.stringify($stateParams)) || {};
            DB.getProject(params.id, function (res) {
                if (res) {
                    vm.state.data = res.data;

                } else {

                }
            });
        };

        if (!vm.state.isInited) {
            vm.init();
            vm.state.isInited = true;
        }

        vm.createNewTask = function (task) {
            var params = {
                title: task.title,
                projectId: vm.state.data.project._id
            };
            DB.createTask(params, function (res) {
                console.log(['createTask', res]);
                if (res) {
                    if(task.redirect) {
                        $state.go('task', {id: res.data.task._id});
                    }
                } else {

                }
            });
        };

        vm.openTask = function (taskId) {
            $state.go('task', {id: taskId});
        };

        vm.deleteTask = function (taskId) {
            var params = {
                title: vm.state.newTaskData.title,
                projectId: vm.state.data.project._id
            };
            DB.deleteTask(params, function (res) {
                console.log(['deleteTask', res]);
                /*if (res) {
                    if(vm.state.newTaskData.redirect) {
                        $state.go('task', {id: res.data.task._id});
                    }
                } else {

                }*/
            });
        };

        vm.showNewTaskForm = function () {

            $mdDialog.show({
                controller: 'PopupNewTaskController',
                templateUrl: 'html/popups/new_task.html'
            })
            .then(function(task) {
                if(!task) {
                    /*$mdDialog.show({
                     controller: 'PopupErrorController',
                     templateUrl: 'html/popups/error.html'
                     });*/
                } else {
                    vm.createNewTask(task);
                }
            });
        };

        vm.onCreateNewTask = function () {
            console.log(['onCreateNewTask']);
            vm.createTask();
        };

        vm.addMessage = function() {
            console.log(['add message']);
        };

        vm.uploadFiles = function() {
            Upload.upload({
                url: 'api/files',
                data: {
                    projectId: vm.state.data.project._id,
                    files: vm.files
                }
            }).then(function (res) {
                console.log(['Success uploaded. Response: ', res]);
                vm.state.data.project.files = res.data.project.files;
            }, function (res) {
                console.log(['Error status: ', res]);
            }, function (evt) {
                var progressPercentage = parseInt(100.0 * evt.loaded / evt.total);
                console.log(['progress: ' + progressPercentage + '% ' + evt]);
            });
        };

        $scope.submit = function () {
            if (form.file.$valid && $scope.file) {
                Upload.upload({
                    url: 'api/files',
                    data: {
                        projectId: vm.state.data.project._id,
                        file: $scope.file,
                        username: $scope.username
                    }
                }).then(function (resp) {
                    console.log('Success ' + resp.config.data.file.name + 'uploaded. Response: ' + resp.data);
                }, function (resp) {
                    console.log('Error status: ' + resp.status);
                }, function (evt) {
                    var progressPercentage = parseInt(100.0 * evt.loaded / evt.total);
                    console.log('progress: ' + progressPercentage + '% ' + evt.config.data.file.name);
                });
            }
        };
    }

})(app);
(function(app){

    app.controller('ProjectsViewController', ProjectsViewController);

    ProjectsViewController.$inject = ['$scope', '$rootScope', '$state', 'Session', 'DB', '$mdDialog'];

    function ProjectsViewController($scope, $rootScope, $state, Session, DB, $mdDialog) {

        var vm = this;
        vm.scope = $scope;
        vm.state = Session.state['ProjectsViewController'] = Session.state['ProjectsViewController'] || {isInited: false};
        vm.translations = Session.state['Translations'];

        vm.init = function () {
            DB.getProjects(function(res){
                if(res) {
                    vm.state.data = res.data;
                } else {

                }
            });
        };

        if (!vm.state.isInited) {
            vm.init();
            vm.state.isInited = true;
        }

        function createNewProject(projectTitle) {
            var params = {
                title: projectTitle
            };

            DB.addProject(params, function(res){
                console.log(['addProject res', res]);
                if(res) {
                    $state.go('project', { id: res.data.project._id });
                } else {
                    /*$mdDialog.show({
                        controller: 'PopupErrorController',
                        templateUrl: 'html/popups/error.html'
                    });*/
                }
            });
        }

        vm.showCreateProjectDialog = function() {
            $mdDialog.show({
                controller: 'PopupNewProjectController',
                templateUrl: 'html/popups/new_project.html'
            })
            .then(function(projectTitle) {
                    if(!projectTitle) {
                        /*$mdDialog.show({
                            controller: 'PopupErrorController',
                            templateUrl: 'html/popups/error.html'
                        });*/
                    } else {
                        createNewProject(projectTitle);
                    }
            });
        };

    }

})(app);

(function(app){

    app.controller('RootController', RootController);

    RootController.$inject = ['$scope', '$rootScope', '$state', '$stateParams', '$mdSidenav', '$mdDialog', 'Session', 'DB'];

    function RootController($scope, $rootScope, $state, $stateParams, $mdSidenav, $mdDialog, Session, DB) {

        var guestProfile = {
            id: '0',
            name: 'Guest',
            email: 'Guest@mail.com',
            img: '',
            lng: 'EN',
            is_logged: false
        };

        var vm = this;
        vm.scope = $scope;
        vm.state = Session.state['RootController'] = Session.state['RootController'] || { isInited: false, profile: guestProfile };

        vm.init = function () {

            /*$mdDialog.show(
                $mdDialog.alert()
                    .parent(angular.element(document.body))
                    .clickOutsideToClose(true)
                    .title('This is an alert title')
                    .content('You can specify some description text in here.')
                    .ariaLabel('Alert Dialog Demo')
                    .ok('Got it!')
            );*/

            /*var confirm = $mdDialog.confirm()
                .title('Would you like to delete your debt?')
                .content('All of the banks have agreed to forgive you your debts.')
                .ariaLabel('Lucky day')
                .ok('Please do it!')
                .cancel('Sounds like a scam');

            $mdDialog.show(confirm).then(function() {
                $scope.status = 'You decided to get rid of your debt.';
            }, function() {
                $scope.status = 'You decided to keep your debt.';
            });*/

            DB.getProfile({}, function(res) {
                if(res) {
                    vm.translations = res.data.translations;
                    Session.state['Translations'] = vm.translations;

                    if (res.data.success) {
                        vm.state.profile = res.data.profile;
                    } else {

                    }
                } else {
                    $mdDialog.show(
                        $mdDialog.alert()
                            .parent(angular.element(document.body))
                            .clickOutsideToClose(true)
                            .title('Error')
                            .content('Fatal Error')
                            .ariaLabel('Error Dialog')
                            .ok('OK')
                    );
                }
            });

            if(!$state.current.name) {
                $state.go('main');
            }

        };

        if (!vm.state.isInited) {
            vm.init();
            vm.state.isInited = true;
        }

        vm.toggleSidenav = function(menuId) {
            $mdSidenav(menuId).toggle();
        };

        vm.onSignInBtn = function () {
            $mdDialog.show({
                controller: 'PopupSignInController',
                templateUrl: 'html/popups/sign_in.html'
            });
        };

        vm.onSignUpBtn = function () {
            $mdDialog.show({
                controller: 'PopupSignUpController',
                templateUrl: 'html/popups/sign_up.html'
            });
        };

        vm.onExitBtn = function () {
            DB.logout({}, function(res) {
                console.log(res);
                if(res.data.success) {
                    window.location.reload();
                } else {

                }
            });
        };
    }
})(app);
(function(app){

    app.controller('ScenesViewController', ScenesViewController);

    ScenesViewController.$inject = ['$scope', '$rootScope', '$state', 'Session', 'DB'];

    function ScenesViewController($scope, $rootScope, $state, Session, DB) {

        var vm = this;
        vm.scope = $scope;
        vm.state = Session.state['ScenesViewController'] = Session.state['ScenesViewController'] || {isInited: false};
        vm.state.filter = {
            executioner: '',
            room: '',
            style:'',
            gamma:'',
            tone: '',
            main_color:'',
            accent_color: '',
            material: ''
        };

        vm.init = function () {
            DB.getScenes(vm.state.filter, function(res) {
                if(res) {
                    vm.state.scenes = res.data;
                } else {

                }
            });
        };

        if (!vm.state.isInited) {
            vm.init();
            vm.state.isInited = true;
        }

        vm.getImgPath = function (url) {
            var result = window.location.origin + '/project_data/scenes/' + url + '.jpg';
            return result;
        };
    }

})(app);

(function(app){

    app.controller('ServiceViewController', ServiceViewController);

    ServiceViewController.$inject = ['$scope', '$rootScope', '$state'];

    function ServiceViewController($scope, $rootScope, $state) {

        var vm = this;
        vm.scope = $scope;
        $rootScope.rootCtrl = vm;

        vm.init = function () {

        };

        vm.init();
    }

})(app);

(function(app){

    app.controller('TaskViewController', TaskViewController);

    TaskViewController.$inject = ['$scope', '$rootScope', '$state', 'Session', 'DB', '$stateParams', 'Upload'];

    function TaskViewController($scope, $rootScope, $state, Session, DB, $stateParams, Upload) {

        var vm = this;
        vm.scope = $scope;
        vm.state = Session.state['TaskViewController'] = Session.state['TaskViewController'] || {isInited: false};
        vm.state.newMessageData = {
            text: ''
        };

        vm.state.showNewTaskForm = false;

        vm.onCreateNewTask = createNewTask;
        vm.onCancelNewTask = cancelNewTask;
        vm.onShowNewTaskForm = showNewTaskForm;
        vm.onAddMessageToChat = addMessageToChat;
        vm.onShowModelView = showModelView;
        vm.onUploadFiles = uploadFiles;

        vm.init = function () {

            var params = JSON.parse(JSON.stringify($stateParams)) || {};
            DB.getTask(params.id, function(res) {
                if(res) {
                    console.log(['getTask', res]);
                    vm.state.data = res.data;
                } else {

                }
            });
        };

        if (!vm.state.isInited) {
            vm.init();
            vm.state.isInited = true;
        }

        function createNewTask() {
            DB.createTask({}, function(res) {
                console.log(['new task res', res]);
            });
            vm.state.showNewTaskForm = false;
        }

        function cancelNewTask() {
            vm.state.showNewTaskForm = false;
        }

        function showNewTaskForm() {
            vm.state.showNewTaskForm = true;
        }

        function addMessageToChat() {
            console.log(['onAddMessageToChat']);
        }

        function showModelView() {
            console.log(['showModelView']);
        }

        function uploadFiles () {
            console.log(['upload files', files]);
            if (files.file.$valid && $scope.file) {
                Upload.upload({
                    url: 'api/files',
                    data: {
                        projectId: vm.state.data.project._id,
                        file: $scope.file,
                        username: $scope.username
                    }
                }).then(function (resp) {
                    console.log('Success ' + resp.config.data.file.name + 'uploaded. Response: ' + resp.data);
                }, function (resp) {
                    console.log('Error status: ' + resp.status);
                }, function (evt) {
                    var progressPercentage = parseInt(100.0 * evt.loaded / evt.total);
                    console.log('progress: ' + progressPercentage + '% ' + evt.config.data.file.name);
                });
            }
        };

    }

})(app);

(function(app){

    app.controller('TasksViewController', TasksViewController);

    TasksViewController.$inject = ['$scope', '$rootScope', '$state', 'Session', 'DB'];

    function TasksViewController($scope, $rootScope, $state, Session, DB) {

        var vm = this;
        vm.scope = $scope;
        vm.state = Session.state['TasksViewController'] = Session.state['TasksViewController'] || {isInited: false};
        vm.state.taskData = {
            title: "Task Title",
            models: [],
            scenes: []
        };

        vm.init = function () {
            DB.getTasks({}, function(res) {
                if(res) {
                    vm.state.tasks = res.data;
                } else {

                }
            });
        };

        if (!vm.state.isInited) {
            vm.init();
            vm.state.isInited = true;
        }
    }

})(app);
